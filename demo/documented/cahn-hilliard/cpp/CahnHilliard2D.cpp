// This code conforms with the UFC specification version 2018.1.0
// and was automatically generated by FFC version 2019.2.0.dev0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
//
// This code was generated with the following parameters:
//

//  add_tabulate_tensor_timing:     False
//  convert_exceptions_to_warnings: False
//  cpp_optimize:                   True
//  cpp_optimize_flags:             '-O2'
//  epsilon:                        1e-14
//  error_control:                  False
//  external_include_dirs:          ''
//  external_includes:              ''
//  external_libraries:             ''
//  external_library_dirs:          ''
//  form_postfix:                   True
//  format:                         'dolfin'
//  generate_dummy_tabulate_tensor: False
//  max_signature_length:           0
//  optimize:                       True
//  precision:                      None
//  quadrature_degree:              None
//  quadrature_rule:                None
//  representation:                 'uflacs'
//  split:                          True

#include "CahnHilliard2D.h"

cahnhilliard2d_finite_element_0::cahnhilliard2d_finite_element_0() : ufc::finite_element()
{
    // Do nothing
}

cahnhilliard2d_finite_element_0::~cahnhilliard2d_finite_element_0()
{
    // Do nothing
}

const char * cahnhilliard2d_finite_element_0::signature() const
{
    return "FiniteElement('Q', quadrilateral, 1)";
}

ufc::shape cahnhilliard2d_finite_element_0::cell_shape() const
{
    return ufc::shape::quadrilateral;
}

std::size_t cahnhilliard2d_finite_element_0::topological_dimension() const
{
    return 2;
}

std::size_t cahnhilliard2d_finite_element_0::geometric_dimension() const
{
    return 2;
}

std::size_t cahnhilliard2d_finite_element_0::space_dimension() const
{
    return 4;
}

std::size_t cahnhilliard2d_finite_element_0::value_rank() const
{
    return 0;
}

std::size_t cahnhilliard2d_finite_element_0::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t cahnhilliard2d_finite_element_0::value_size() const
{
    return 1;
}

std::size_t cahnhilliard2d_finite_element_0::reference_value_rank() const
{
    return 0;
}

std::size_t cahnhilliard2d_finite_element_0::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t cahnhilliard2d_finite_element_0::reference_value_size() const
{
    return 1;
}

std::size_t cahnhilliard2d_finite_element_0::degree() const
{
    return 1;
}

const char * cahnhilliard2d_finite_element_0::family() const
{
    return "Q";
}

void cahnhilliard2d_finite_element_0::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_0::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis_derivatives: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_0::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    throw std::runtime_error("transform_reference_basis_derivatives: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_0::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    throw std::runtime_error("evaluate_basis: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_0::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    throw std::runtime_error("evaluate_basis_all: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_0::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives: Function is not supported/implemented." << std::endl;
}

void cahnhilliard2d_finite_element_0::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives_all: Function is not supported/implemented." << std::endl;
}

double cahnhilliard2d_finite_element_0::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
}

void cahnhilliard2d_finite_element_0::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
}

void cahnhilliard2d_finite_element_0::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
    vertex_values[3] = dof_values[3];
}

void cahnhilliard2d_finite_element_0::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = coordinate_dofs[6];
    dof_coordinates[2 * 3 + 1] = coordinate_dofs[7];
}

void cahnhilliard2d_finite_element_0::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[8] = { 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0 };
    std::copy_n(dof_X, 8, reference_dof_coordinates);
}

std::size_t cahnhilliard2d_finite_element_0::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * cahnhilliard2d_finite_element_0::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * cahnhilliard2d_finite_element_0::create() const
{
    return new cahnhilliard2d_finite_element_0();
}


cahnhilliard2d_finite_element_1::cahnhilliard2d_finite_element_1() : ufc::finite_element()
{
    // Do nothing
}

cahnhilliard2d_finite_element_1::~cahnhilliard2d_finite_element_1()
{
    // Do nothing
}

const char * cahnhilliard2d_finite_element_1::signature() const
{
    return "VectorElement(FiniteElement('Q', quadrilateral, 1), dim=2)";
}

ufc::shape cahnhilliard2d_finite_element_1::cell_shape() const
{
    return ufc::shape::quadrilateral;
}

std::size_t cahnhilliard2d_finite_element_1::topological_dimension() const
{
    return 2;
}

std::size_t cahnhilliard2d_finite_element_1::geometric_dimension() const
{
    return 2;
}

std::size_t cahnhilliard2d_finite_element_1::space_dimension() const
{
    return 8;
}

std::size_t cahnhilliard2d_finite_element_1::value_rank() const
{
    return 1;
}

std::size_t cahnhilliard2d_finite_element_1::value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t cahnhilliard2d_finite_element_1::value_size() const
{
    return 2;
}

std::size_t cahnhilliard2d_finite_element_1::reference_value_rank() const
{
    return 1;
}

std::size_t cahnhilliard2d_finite_element_1::reference_value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t cahnhilliard2d_finite_element_1::reference_value_size() const
{
    return 2;
}

std::size_t cahnhilliard2d_finite_element_1::degree() const
{
    return 1;
}

const char * cahnhilliard2d_finite_element_1::family() const
{
    return "Q";
}

void cahnhilliard2d_finite_element_1::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_1::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis_derivatives: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_1::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    throw std::runtime_error("transform_reference_basis_derivatives: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_1::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    throw std::runtime_error("evaluate_basis: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_1::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    throw std::runtime_error("evaluate_basis_all: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_1::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives: Function is not supported/implemented." << std::endl;
}

void cahnhilliard2d_finite_element_1::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives_all: Function is not supported/implemented." << std::endl;
}

double cahnhilliard2d_finite_element_1::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 5:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 6:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 7:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    }
    return 0.0;
}

void cahnhilliard2d_finite_element_1::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
}

void cahnhilliard2d_finite_element_1::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    vertex_values[6] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[4];
    vertex_values[3] = dof_values[5];
    vertex_values[5] = dof_values[6];
    vertex_values[7] = dof_values[7];
}

void cahnhilliard2d_finite_element_1::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = coordinate_dofs[6];
    dof_coordinates[2 * 3 + 1] = coordinate_dofs[7];
    dof_coordinates[2 * 4] = coordinate_dofs[0];
    dof_coordinates[2 * 4 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 5] = coordinate_dofs[2];
    dof_coordinates[2 * 5 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 6] = coordinate_dofs[4];
    dof_coordinates[2 * 6 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 7] = coordinate_dofs[6];
    dof_coordinates[2 * 7 + 1] = coordinate_dofs[7];
}

void cahnhilliard2d_finite_element_1::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[16] = { 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0 };
    std::copy_n(dof_X, 16, reference_dof_coordinates);
}

std::size_t cahnhilliard2d_finite_element_1::num_sub_elements() const
{
    return 2;
}

ufc::finite_element * cahnhilliard2d_finite_element_1::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new cahnhilliard2d_finite_element_0();
    case 1:
        return new cahnhilliard2d_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::finite_element * cahnhilliard2d_finite_element_1::create() const
{
    return new cahnhilliard2d_finite_element_1();
}


cahnhilliard2d_finite_element_2::cahnhilliard2d_finite_element_2() : ufc::finite_element()
{
    // Do nothing
}

cahnhilliard2d_finite_element_2::~cahnhilliard2d_finite_element_2()
{
    // Do nothing
}

const char * cahnhilliard2d_finite_element_2::signature() const
{
    return "MixedElement(FiniteElement('Q', quadrilateral, 1), FiniteElement('Q', quadrilateral, 1))";
}

ufc::shape cahnhilliard2d_finite_element_2::cell_shape() const
{
    return ufc::shape::quadrilateral;
}

std::size_t cahnhilliard2d_finite_element_2::topological_dimension() const
{
    return 2;
}

std::size_t cahnhilliard2d_finite_element_2::geometric_dimension() const
{
    return 2;
}

std::size_t cahnhilliard2d_finite_element_2::space_dimension() const
{
    return 8;
}

std::size_t cahnhilliard2d_finite_element_2::value_rank() const
{
    return 1;
}

std::size_t cahnhilliard2d_finite_element_2::value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t cahnhilliard2d_finite_element_2::value_size() const
{
    return 2;
}

std::size_t cahnhilliard2d_finite_element_2::reference_value_rank() const
{
    return 1;
}

std::size_t cahnhilliard2d_finite_element_2::reference_value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t cahnhilliard2d_finite_element_2::reference_value_size() const
{
    return 2;
}

std::size_t cahnhilliard2d_finite_element_2::degree() const
{
    return 1;
}

const char * cahnhilliard2d_finite_element_2::family() const
{
    return "Mixed";
}

void cahnhilliard2d_finite_element_2::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_2::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis_derivatives: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_2::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    throw std::runtime_error("transform_reference_basis_derivatives: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_2::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    throw std::runtime_error("evaluate_basis: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_2::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    throw std::runtime_error("evaluate_basis_all: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_2::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives: Function is not supported/implemented." << std::endl;
}

void cahnhilliard2d_finite_element_2::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives_all: Function is not supported/implemented." << std::endl;
}

double cahnhilliard2d_finite_element_2::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 5:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 6:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 7:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    }
    return 0.0;
}

void cahnhilliard2d_finite_element_2::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
}

void cahnhilliard2d_finite_element_2::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    vertex_values[6] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[4];
    vertex_values[3] = dof_values[5];
    vertex_values[5] = dof_values[6];
    vertex_values[7] = dof_values[7];
}

void cahnhilliard2d_finite_element_2::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = coordinate_dofs[6];
    dof_coordinates[2 * 3 + 1] = coordinate_dofs[7];
    dof_coordinates[2 * 4] = coordinate_dofs[0];
    dof_coordinates[2 * 4 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 5] = coordinate_dofs[2];
    dof_coordinates[2 * 5 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 6] = coordinate_dofs[4];
    dof_coordinates[2 * 6 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 7] = coordinate_dofs[6];
    dof_coordinates[2 * 7 + 1] = coordinate_dofs[7];
}

void cahnhilliard2d_finite_element_2::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[16] = { 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0 };
    std::copy_n(dof_X, 16, reference_dof_coordinates);
}

std::size_t cahnhilliard2d_finite_element_2::num_sub_elements() const
{
    return 2;
}

ufc::finite_element * cahnhilliard2d_finite_element_2::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new cahnhilliard2d_finite_element_0();
    case 1:
        return new cahnhilliard2d_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::finite_element * cahnhilliard2d_finite_element_2::create() const
{
    return new cahnhilliard2d_finite_element_2();
}


cahnhilliard2d_finite_element_3::cahnhilliard2d_finite_element_3() : ufc::finite_element()
{
    // Do nothing
}

cahnhilliard2d_finite_element_3::~cahnhilliard2d_finite_element_3()
{
    // Do nothing
}

const char * cahnhilliard2d_finite_element_3::signature() const
{
    return "FiniteElement('Real', quadrilateral, 0)";
}

ufc::shape cahnhilliard2d_finite_element_3::cell_shape() const
{
    return ufc::shape::quadrilateral;
}

std::size_t cahnhilliard2d_finite_element_3::topological_dimension() const
{
    return 2;
}

std::size_t cahnhilliard2d_finite_element_3::geometric_dimension() const
{
    return 2;
}

std::size_t cahnhilliard2d_finite_element_3::space_dimension() const
{
    return 1;
}

std::size_t cahnhilliard2d_finite_element_3::value_rank() const
{
    return 0;
}

std::size_t cahnhilliard2d_finite_element_3::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t cahnhilliard2d_finite_element_3::value_size() const
{
    return 1;
}

std::size_t cahnhilliard2d_finite_element_3::reference_value_rank() const
{
    return 0;
}

std::size_t cahnhilliard2d_finite_element_3::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t cahnhilliard2d_finite_element_3::reference_value_size() const
{
    return 1;
}

std::size_t cahnhilliard2d_finite_element_3::degree() const
{
    return 0;
}

const char * cahnhilliard2d_finite_element_3::family() const
{
    return "Real";
}

void cahnhilliard2d_finite_element_3::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_3::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis_derivatives: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_3::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    throw std::runtime_error("transform_reference_basis_derivatives: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_3::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    throw std::runtime_error("evaluate_basis: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_3::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    throw std::runtime_error("evaluate_basis_all: Function is not supported/implemented.");
}

void cahnhilliard2d_finite_element_3::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives: Function is not supported/implemented." << std::endl;
}

void cahnhilliard2d_finite_element_3::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives_all: Function is not supported/implemented." << std::endl;
}

double cahnhilliard2d_finite_element_3::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[6];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[7];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
}

void cahnhilliard2d_finite_element_3::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[6];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[7];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
}

void cahnhilliard2d_finite_element_3::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
    vertex_values[3] = dof_values[0];
}

void cahnhilliard2d_finite_element_3::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[6];
    dof_coordinates[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[7];
}

void cahnhilliard2d_finite_element_3::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[2] = { 0.5, 0.5 };
    std::copy_n(dof_X, 2, reference_dof_coordinates);
}

std::size_t cahnhilliard2d_finite_element_3::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * cahnhilliard2d_finite_element_3::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * cahnhilliard2d_finite_element_3::create() const
{
    return new cahnhilliard2d_finite_element_3();
}


cahnhilliard2d_dofmap_0::cahnhilliard2d_dofmap_0() : ufc::dofmap()
{
    // Do nothing
}

cahnhilliard2d_dofmap_0::~cahnhilliard2d_dofmap_0()
{
    // Do nothing
}

const char * cahnhilliard2d_dofmap_0::signature() const
{
    return "FFC dofmap for FiniteElement('Q', quadrilateral, 1)";
}

bool cahnhilliard2d_dofmap_0::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t cahnhilliard2d_dofmap_0::topological_dimension() const
{
    return 2;
}

std::size_t cahnhilliard2d_dofmap_0::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return num_global_entities[0];
}

std::size_t cahnhilliard2d_dofmap_0::num_global_support_dofs() const
{
    return 0;
}

std::size_t cahnhilliard2d_dofmap_0::num_element_support_dofs() const
{
    return 4;
}

std::size_t cahnhilliard2d_dofmap_0::num_element_dofs() const
{
    return 4;
}

std::size_t cahnhilliard2d_dofmap_0::num_facet_dofs() const
{
    return 2;
}

std::size_t cahnhilliard2d_dofmap_0::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 1, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t cahnhilliard2d_dofmap_0::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 1, 2, 4 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void cahnhilliard2d_dofmap_0::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    dofs[0] = entity_indices[0][0];
    dofs[1] = entity_indices[0][1];
    dofs[2] = entity_indices[0][2];
    dofs[3] = entity_indices[0][3];
}

void cahnhilliard2d_dofmap_0::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 0;
        dofs[1] = 1;
        break;
    case 1:
        dofs[0] = 2;
        dofs[1] = 3;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 2;
        break;
    case 3:
        dofs[0] = 1;
        dofs[1] = 3;
        break;
    }
}

void cahnhilliard2d_dofmap_0::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        case 3:
            dofs[0] = 3;
            break;
        }
        break;
    }
}

void cahnhilliard2d_dofmap_0::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        case 3:
            dofs[0] = 3;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            break;
        case 1:
            dofs[0] = 2;
            dofs[1] = 3;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 2;
            break;
        case 3:
            dofs[0] = 1;
            dofs[1] = 3;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            break;
        }
        break;
    }
}

std::size_t cahnhilliard2d_dofmap_0::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * cahnhilliard2d_dofmap_0::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * cahnhilliard2d_dofmap_0::create() const
{
    return new cahnhilliard2d_dofmap_0();
}


cahnhilliard2d_dofmap_1::cahnhilliard2d_dofmap_1() : ufc::dofmap()
{
    // Do nothing
}

cahnhilliard2d_dofmap_1::~cahnhilliard2d_dofmap_1()
{
    // Do nothing
}

const char * cahnhilliard2d_dofmap_1::signature() const
{
    return "FFC dofmap for VectorElement(FiniteElement('Q', quadrilateral, 1), dim=2)";
}

bool cahnhilliard2d_dofmap_1::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t cahnhilliard2d_dofmap_1::topological_dimension() const
{
    return 2;
}

std::size_t cahnhilliard2d_dofmap_1::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 2 * num_global_entities[0];
}

std::size_t cahnhilliard2d_dofmap_1::num_global_support_dofs() const
{
    return 0;
}

std::size_t cahnhilliard2d_dofmap_1::num_element_support_dofs() const
{
    return 8;
}

std::size_t cahnhilliard2d_dofmap_1::num_element_dofs() const
{
    return 8;
}

std::size_t cahnhilliard2d_dofmap_1::num_facet_dofs() const
{
    return 4;
}

std::size_t cahnhilliard2d_dofmap_1::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 2, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t cahnhilliard2d_dofmap_1::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 2, 4, 8 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void cahnhilliard2d_dofmap_1::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    dofs[3] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[4] = offset + entity_indices[0][0];
    dofs[5] = offset + entity_indices[0][1];
    dofs[6] = offset + entity_indices[0][2];
    dofs[7] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
}

void cahnhilliard2d_dofmap_1::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 4;
        dofs[3] = 5;
        break;
    case 1:
        dofs[0] = 2;
        dofs[1] = 3;
        dofs[2] = 6;
        dofs[3] = 7;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 4;
        dofs[3] = 6;
        break;
    case 3:
        dofs[0] = 1;
        dofs[1] = 3;
        dofs[2] = 5;
        dofs[3] = 7;
        break;
    }
}

void cahnhilliard2d_dofmap_1::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 4;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 5;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 6;
            break;
        case 3:
            dofs[0] = 3;
            dofs[1] = 7;
            break;
        }
        break;
    }
}

void cahnhilliard2d_dofmap_1::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 4;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 5;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 6;
            break;
        case 3:
            dofs[0] = 3;
            dofs[1] = 7;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 4;
            dofs[3] = 5;
            break;
        case 1:
            dofs[0] = 2;
            dofs[1] = 3;
            dofs[2] = 6;
            dofs[3] = 7;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 6;
            break;
        case 3:
            dofs[0] = 1;
            dofs[1] = 3;
            dofs[2] = 5;
            dofs[3] = 7;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            break;
        }
        break;
    }
}

std::size_t cahnhilliard2d_dofmap_1::num_sub_dofmaps() const
{
    return 2;
}

ufc::dofmap * cahnhilliard2d_dofmap_1::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new cahnhilliard2d_dofmap_0();
    case 1:
        return new cahnhilliard2d_dofmap_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * cahnhilliard2d_dofmap_1::create() const
{
    return new cahnhilliard2d_dofmap_1();
}


cahnhilliard2d_dofmap_2::cahnhilliard2d_dofmap_2() : ufc::dofmap()
{
    // Do nothing
}

cahnhilliard2d_dofmap_2::~cahnhilliard2d_dofmap_2()
{
    // Do nothing
}

const char * cahnhilliard2d_dofmap_2::signature() const
{
    return "FFC dofmap for MixedElement(FiniteElement('Q', quadrilateral, 1), FiniteElement('Q', quadrilateral, 1))";
}

bool cahnhilliard2d_dofmap_2::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t cahnhilliard2d_dofmap_2::topological_dimension() const
{
    return 2;
}

std::size_t cahnhilliard2d_dofmap_2::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 2 * num_global_entities[0];
}

std::size_t cahnhilliard2d_dofmap_2::num_global_support_dofs() const
{
    return 0;
}

std::size_t cahnhilliard2d_dofmap_2::num_element_support_dofs() const
{
    return 8;
}

std::size_t cahnhilliard2d_dofmap_2::num_element_dofs() const
{
    return 8;
}

std::size_t cahnhilliard2d_dofmap_2::num_facet_dofs() const
{
    return 4;
}

std::size_t cahnhilliard2d_dofmap_2::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 2, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t cahnhilliard2d_dofmap_2::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 2, 4, 8 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void cahnhilliard2d_dofmap_2::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    dofs[3] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[4] = offset + entity_indices[0][0];
    dofs[5] = offset + entity_indices[0][1];
    dofs[6] = offset + entity_indices[0][2];
    dofs[7] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
}

void cahnhilliard2d_dofmap_2::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 4;
        dofs[3] = 5;
        break;
    case 1:
        dofs[0] = 2;
        dofs[1] = 3;
        dofs[2] = 6;
        dofs[3] = 7;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 4;
        dofs[3] = 6;
        break;
    case 3:
        dofs[0] = 1;
        dofs[1] = 3;
        dofs[2] = 5;
        dofs[3] = 7;
        break;
    }
}

void cahnhilliard2d_dofmap_2::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 4;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 5;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 6;
            break;
        case 3:
            dofs[0] = 3;
            dofs[1] = 7;
            break;
        }
        break;
    }
}

void cahnhilliard2d_dofmap_2::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 4;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 5;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 6;
            break;
        case 3:
            dofs[0] = 3;
            dofs[1] = 7;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 4;
            dofs[3] = 5;
            break;
        case 1:
            dofs[0] = 2;
            dofs[1] = 3;
            dofs[2] = 6;
            dofs[3] = 7;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 6;
            break;
        case 3:
            dofs[0] = 1;
            dofs[1] = 3;
            dofs[2] = 5;
            dofs[3] = 7;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            break;
        }
        break;
    }
}

std::size_t cahnhilliard2d_dofmap_2::num_sub_dofmaps() const
{
    return 2;
}

ufc::dofmap * cahnhilliard2d_dofmap_2::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new cahnhilliard2d_dofmap_0();
    case 1:
        return new cahnhilliard2d_dofmap_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * cahnhilliard2d_dofmap_2::create() const
{
    return new cahnhilliard2d_dofmap_2();
}


cahnhilliard2d_dofmap_3::cahnhilliard2d_dofmap_3() : ufc::dofmap()
{
    // Do nothing
}

cahnhilliard2d_dofmap_3::~cahnhilliard2d_dofmap_3()
{
    // Do nothing
}

const char * cahnhilliard2d_dofmap_3::signature() const
{
    return "FFC dofmap for FiniteElement('Real', quadrilateral, 0)";
}

bool cahnhilliard2d_dofmap_3::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = {};
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t cahnhilliard2d_dofmap_3::topological_dimension() const
{
    return 2;
}

std::size_t cahnhilliard2d_dofmap_3::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 1;
}

std::size_t cahnhilliard2d_dofmap_3::num_global_support_dofs() const
{
    return 1;
}

std::size_t cahnhilliard2d_dofmap_3::num_element_support_dofs() const
{
    return 0;
}

std::size_t cahnhilliard2d_dofmap_3::num_element_dofs() const
{
    return 1;
}

std::size_t cahnhilliard2d_dofmap_3::num_facet_dofs() const
{
    return 0;
}

std::size_t cahnhilliard2d_dofmap_3::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 0, 0, 1 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t cahnhilliard2d_dofmap_3::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 0, 0, 1 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void cahnhilliard2d_dofmap_3::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    dofs[0] = 0;
}

void cahnhilliard2d_dofmap_3::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    // Do nothing
}

void cahnhilliard2d_dofmap_3::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
}

void cahnhilliard2d_dofmap_3::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
}

std::size_t cahnhilliard2d_dofmap_3::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * cahnhilliard2d_dofmap_3::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * cahnhilliard2d_dofmap_3::create() const
{
    return new cahnhilliard2d_dofmap_3();
}


cahnhilliard2d_coordinate_mapping_1::cahnhilliard2d_coordinate_mapping_1() : ufc::coordinate_mapping()
{
    // Do nothing
}

cahnhilliard2d_coordinate_mapping_1::~cahnhilliard2d_coordinate_mapping_1()
{
    // Do nothing
}

const char * cahnhilliard2d_coordinate_mapping_1::signature() const
{
    return "FFC coordinate_mapping from VectorElement(FiniteElement('Q', quadrilateral, 1), dim=2)";
}

ufc::coordinate_mapping * cahnhilliard2d_coordinate_mapping_1::create() const
{
    return new cahnhilliard2d_coordinate_mapping_1();
}

std::size_t cahnhilliard2d_coordinate_mapping_1::geometric_dimension() const
{
    return 2;
}

std::size_t cahnhilliard2d_coordinate_mapping_1::topological_dimension() const
{
    return 2;
}

ufc::shape cahnhilliard2d_coordinate_mapping_1::cell_shape() const
{
    return ufc::shape::quadrilateral;
}

ufc::finite_element * cahnhilliard2d_coordinate_mapping_1::create_coordinate_finite_element() const
{
    return new cahnhilliard2d_finite_element_1();
}

ufc::dofmap * cahnhilliard2d_coordinate_mapping_1::create_coordinate_dofmap() const
{
    return new cahnhilliard2d_dofmap_1();
}

void cahnhilliard2d_coordinate_mapping_1::compute_physical_coordinates(
    double * x, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs) const
{
    cahnhilliard2d_finite_element_0 xelement;
    double phi[4];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis values of coordinate element
        xelement.evaluate_reference_basis(phi, 1, &X[2 * ip]);
        // Compute x
        for (std::size_t i = 0; i < 2; ++i)
            for (std::size_t d = 0; d < 4; ++d)
                x[2 * ip + i] += coordinate_dofs[2 * d + i] * phi[d];
    }
}

void cahnhilliard2d_coordinate_mapping_1::compute_reference_coordinates(
    double * X, std::size_t num_points,
    const double * x,
    const double * coordinate_dofs, int cell_orientation) const
{
    const double phi_X0[4] = { 1.0, 0.0, 0.0, 0.0 };
    const double dphi_X0[2][4] =
        { { -1.0, 0.0, 1.0, 0.0 },
          { -1.0, 1.0, 0.0, 0.0 } };
    double J[4];
    double detJ[1];
    double K[4];
    double x0[2] = {};
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t k = 0; k < 4; ++k)
            x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 2; ++i)
    {
        for (std::size_t j = 0; j < 2; ++j)
        {
            J[2 * i + j] = 0.0;
            for (std::size_t k = 0; k < 4; ++k)
                J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t i = 0; i < 2; ++i)
                X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
}

void cahnhilliard2d_coordinate_mapping_1::compute_reference_geometry(
    double * X, double * J, double * detJ, double * K, std::size_t num_points,
    const double * x,
    const double * coordinate_dofs, int cell_orientation) const
{
    const double phi_X0[4] = { 1.0, 0.0, 0.0, 0.0 };
    const double dphi_X0[2][4] =
        { { -1.0, 0.0, 1.0, 0.0 },
          { -1.0, 1.0, 0.0, 0.0 } };
    double x0[2] = {};
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t k = 0; k < 4; ++k)
            x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 2; ++i)
    {
        for (std::size_t j = 0; j < 2; ++j)
        {
            J[2 * i + j] = 0.0;
            for (std::size_t k = 0; k < 4; ++k)
                J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t i = 0; i < 2; ++i)
                X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
}

void cahnhilliard2d_coordinate_mapping_1::compute_jacobians(
    double * J, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs) const
{
    cahnhilliard2d_finite_element_0 xelement;
    double dphi[8];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis derivatives of coordinate element
        xelement.evaluate_reference_basis_derivatives(dphi, 1, 1, &X[2 * ip]);
        // Compute J
        for (std::size_t i = 0; i < 2; ++i)
            for (std::size_t j = 0; j < 2; ++j)
                for (std::size_t d = 0; d < 4; ++d)
                    J[2 * 2 * ip + 2 * i + j] += coordinate_dofs[2 * d + i] * dphi[2 * d + j];
    }
}

void cahnhilliard2d_coordinate_mapping_1::compute_jacobian_determinants(
    double * detJ, std::size_t num_points,
    const double * J,
    int cell_orientation) const
{
    for (std::size_t ip = 0; ip < num_points; ++ip)
        detJ[ip] = J[2 * 2 * ip] * J[2 * 2 * ip + 2 + 1] - J[2 * 2 * ip + 1] * J[2 * 2 * ip + 2];
}

void cahnhilliard2d_coordinate_mapping_1::compute_jacobian_inverses(
    double * K, std::size_t num_points,
    const double * J, const double * detJ) const
{
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        K[2 * 2 * ip] = J[2 * 2 * ip + 2 + 1] / detJ[ip];
        K[2 * 2 * ip + 1] = -J[2 * 2 * ip + 1] / detJ[ip];
        K[2 * 2 * ip + 2] = -J[2 * 2 * ip + 2] / detJ[ip];
        K[2 * 2 * ip + 2 + 1] = J[2 * 2 * ip] / detJ[ip];
    }
}

void cahnhilliard2d_coordinate_mapping_1::compute_geometry(
    double * x, double * J, double * detJ, double * K, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs, int cell_orientation) const
{
    compute_physical_coordinates(x, num_points, X, coordinate_dofs);
    compute_jacobians(J, num_points, X, coordinate_dofs);
    compute_jacobian_determinants(detJ, num_points, J, cell_orientation);
    compute_jacobian_inverses(K, num_points, J, detJ);
}

void cahnhilliard2d_coordinate_mapping_1::compute_midpoint_geometry(
    double * x, double * J,
    const double * coordinate_dofs) const
{
    const double phi_Xm[4] = { 0.25, 0.25, 0.25, 0.25 };
    const double dphi_Xm[2][4] =
        { { -0.5, -0.5, 0.5, 0.5 },
          { -0.5, 0.5, -0.5, 0.5 } };
    // Compute x
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t d = 0; d < 4; ++d)
            x[i] += coordinate_dofs[2 * d + i] * phi_Xm[d];
    // Compute J
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t d = 0; d < 4; ++d)
                J[2 * i + j] += coordinate_dofs[2 * d + i] * dphi_Xm[j][d];
}


cahnhilliard2d_cell_integral_0_otherwise::cahnhilliard2d_cell_integral_0_otherwise() : ufc::cell_integral()
{

}

cahnhilliard2d_cell_integral_0_otherwise::~cahnhilliard2d_cell_integral_0_otherwise()
{

}

const std::vector<bool> & cahnhilliard2d_cell_integral_0_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true, true});
return enabled;
}

void cahnhilliard2d_cell_integral_0_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation,
                                    std::size_t local_facet) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 6
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights16[16] = { 0.03025074832140047, 0.05671296296296294, 0.05671296296296294, 0.03025074832140047, 0.05671296296296294, 0.1063233257526736, 0.1063233257526736, 0.05671296296296294, 0.05671296296296294, 0.1063233257526736, 0.1063233257526736, 0.05671296296296294, 0.03025074832140047, 0.05671296296296294, 0.05671296296296294, 0.03025074832140047 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE19_C0_D01_Q16[1][16][4] =
        { { { -0.9305681557970262, 0.9305681557970262, -0.06943184420297371, 0.06943184420297371 },
            { -0.9305681557970262, 0.9305681557970262, -0.06943184420297371, 0.06943184420297371 },
            { -0.9305681557970262, 0.9305681557970262, -0.06943184420297371, 0.06943184420297371 },
            { -0.9305681557970262, 0.9305681557970262, -0.06943184420297371, 0.06943184420297371 },
            { -0.6699905217924281, 0.6699905217924281, -0.3300094782075719, 0.3300094782075719 },
            { -0.6699905217924281, 0.6699905217924281, -0.3300094782075719, 0.3300094782075719 },
            { -0.6699905217924281, 0.6699905217924281, -0.3300094782075719, 0.3300094782075719 },
            { -0.6699905217924281, 0.6699905217924281, -0.3300094782075719, 0.3300094782075719 },
            { -0.3300094782075719, 0.3300094782075719, -0.6699905217924281, 0.6699905217924281 },
            { -0.3300094782075719, 0.3300094782075719, -0.6699905217924281, 0.6699905217924281 },
            { -0.3300094782075719, 0.3300094782075719, -0.6699905217924281, 0.6699905217924281 },
            { -0.3300094782075719, 0.3300094782075719, -0.6699905217924281, 0.6699905217924281 },
            { -0.06943184420297371, 0.06943184420297371, -0.9305681557970262, 0.9305681557970262 },
            { -0.06943184420297371, 0.06943184420297371, -0.9305681557970262, 0.9305681557970262 },
            { -0.06943184420297371, 0.06943184420297371, -0.9305681557970262, 0.9305681557970262 },
            { -0.06943184420297371, 0.06943184420297371, -0.9305681557970262, 0.9305681557970262 } } };
    alignas(32) static const double FE19_C0_D10_Q16[1][16][4] =
        { { { -0.9305681557970262, -0.06943184420297371, 0.9305681557970262, 0.06943184420297371 },
            { -0.6699905217924281, -0.3300094782075719, 0.6699905217924281, 0.3300094782075719 },
            { -0.3300094782075719, -0.6699905217924281, 0.3300094782075719, 0.6699905217924281 },
            { -0.06943184420297371, -0.9305681557970262, 0.06943184420297371, 0.9305681557970262 },
            { -0.9305681557970262, -0.06943184420297371, 0.9305681557970262, 0.06943184420297371 },
            { -0.6699905217924281, -0.3300094782075719, 0.6699905217924281, 0.3300094782075719 },
            { -0.3300094782075719, -0.6699905217924281, 0.3300094782075719, 0.6699905217924281 },
            { -0.06943184420297371, -0.9305681557970262, 0.06943184420297371, 0.9305681557970262 },
            { -0.9305681557970262, -0.06943184420297371, 0.9305681557970262, 0.06943184420297371 },
            { -0.6699905217924281, -0.3300094782075719, 0.6699905217924281, 0.3300094782075719 },
            { -0.3300094782075719, -0.6699905217924281, 0.3300094782075719, 0.6699905217924281 },
            { -0.06943184420297371, -0.9305681557970262, 0.06943184420297371, 0.9305681557970262 },
            { -0.9305681557970262, -0.06943184420297371, 0.9305681557970262, 0.06943184420297371 },
            { -0.6699905217924281, -0.3300094782075719, 0.6699905217924281, 0.3300094782075719 },
            { -0.3300094782075719, -0.6699905217924281, 0.3300094782075719, 0.6699905217924281 },
            { -0.06943184420297371, -0.9305681557970262, 0.06943184420297371, 0.9305681557970262 } } };
    alignas(32) static const double FE19_C0_Q16[1][16][4] =
        { { { 0.8659570925834785, 0.06461106321354769, 0.06461106321354769, 0.004820780989426014 },
            { 0.6234718442658671, 0.3070963115311591, 0.04651867752656094, 0.02291316667641278 },
            { 0.3070963115311591, 0.6234718442658671, 0.02291316667641278, 0.04651867752656094 },
            { 0.06461106321354769, 0.8659570925834785, 0.004820780989426014, 0.06461106321354769 },
            { 0.6234718442658671, 0.04651867752656094, 0.3070963115311591, 0.02291316667641278 },
            { 0.4488872992916901, 0.221103222500738, 0.221103222500738, 0.1089062557068338 },
            { 0.221103222500738, 0.4488872992916901, 0.1089062557068338, 0.221103222500738 },
            { 0.04651867752656094, 0.6234718442658671, 0.02291316667641278, 0.3070963115311591 },
            { 0.3070963115311591, 0.02291316667641278, 0.6234718442658671, 0.04651867752656094 },
            { 0.221103222500738, 0.1089062557068338, 0.4488872992916901, 0.221103222500738 },
            { 0.1089062557068338, 0.221103222500738, 0.221103222500738, 0.4488872992916901 },
            { 0.02291316667641278, 0.3070963115311591, 0.04651867752656094, 0.6234718442658671 },
            { 0.06461106321354769, 0.004820780989426014, 0.8659570925834785, 0.06461106321354769 },
            { 0.04651867752656094, 0.02291316667641278, 0.6234718442658671, 0.3070963115311591 },
            { 0.02291316667641278, 0.04651867752656094, 0.3070963115311591, 0.6234718442658671 },
            { 0.004820780989426014, 0.06461106321354769, 0.06461106321354769, 0.8659570925834785 } } };
    alignas(32) double BF0[4] = {};
    alignas(32) double BF1[4] = {};
    alignas(32) double BF2[4] = {};
    alignas(32) double BF3[4] = {};
    alignas(32) double BF4[4] = {};
    alignas(32) double BF5[4] = {};
    for (int iq = 0; iq < 16; ++iq)
    {
        // Quadrature loop body setup (num_points=16)
        // Unstructured varying computations for num_points=16
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 4; ++ic)
            w0_c0 += w[0][ic] * FE19_C0_Q16[0][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 4; ++ic)
            w0_c1 += w[0][ic + 4] * FE19_C0_Q16[0][iq][ic];
        double w1_c0 = 0.0;
        for (int ic = 0; ic < 4; ++ic)
            w1_c0 += w[1][ic] * FE19_C0_Q16[0][iq][ic];
        double w0_d1_c0 = 0.0;
        for (int ic = 0; ic < 4; ++ic)
            w0_d1_c0 += w[0][ic] * FE19_C0_D01_Q16[0][iq][ic];
        const double J_c0 = coordinate_dofs[0] * FE19_C0_D10_Q16[0][iq][0] + coordinate_dofs[2] * FE19_C0_D10_Q16[0][iq][1] + coordinate_dofs[4] * FE19_C0_D10_Q16[0][iq][2] + coordinate_dofs[6] * FE19_C0_D10_Q16[0][iq][3];
        const double J_c3 = coordinate_dofs[1] * FE19_C0_D01_Q16[0][iq][0] + coordinate_dofs[3] * FE19_C0_D01_Q16[0][iq][1] + coordinate_dofs[5] * FE19_C0_D01_Q16[0][iq][2] + coordinate_dofs[7] * FE19_C0_D01_Q16[0][iq][3];
        const double J_c1 = coordinate_dofs[0] * FE19_C0_D01_Q16[0][iq][0] + coordinate_dofs[2] * FE19_C0_D01_Q16[0][iq][1] + coordinate_dofs[4] * FE19_C0_D01_Q16[0][iq][2] + coordinate_dofs[6] * FE19_C0_D01_Q16[0][iq][3];
        const double J_c2 = coordinate_dofs[1] * FE19_C0_D10_Q16[0][iq][0] + coordinate_dofs[3] * FE19_C0_D10_Q16[0][iq][1] + coordinate_dofs[5] * FE19_C0_D10_Q16[0][iq][2] + coordinate_dofs[7] * FE19_C0_D10_Q16[0][iq][3];
        double w0_d0_c0 = 0.0;
        for (int ic = 0; ic < 4; ++ic)
            w0_d0_c0 += w[0][ic] * FE19_C0_D10_Q16[0][iq][ic];
        double w1_d1_c1 = 0.0;
        for (int ic = 0; ic < 4; ++ic)
            w1_d1_c1 += w[1][ic + 4] * FE19_C0_D01_Q16[0][iq][ic];
        double w1_d0_c1 = 0.0;
        for (int ic = 0; ic < 4; ++ic)
            w1_d0_c1 += w[1][ic + 4] * FE19_C0_D10_Q16[0][iq][ic];
        double w0_d1_c1 = 0.0;
        for (int ic = 0; ic < 4; ++ic)
            w0_d1_c1 += w[0][ic + 4] * FE19_C0_D01_Q16[0][iq][ic];
        double w0_d0_c1 = 0.0;
        for (int ic = 0; ic < 4; ++ic)
            w0_d0_c1 += w[0][ic + 4] * FE19_C0_D10_Q16[0][iq][ic];
        alignas(32) double sv16[59];
        sv16[0] = w0_c0 + -1 * w1_c0;
        sv16[1] = -2.0 * (1 + -1 * w0_c0) * (100 * std::pow(w0_c0, 2));
        sv16[2] = 100 * (2.0 * w0_c0) * std::pow(1 + -1 * w0_c0, 2);
        sv16[3] = sv16[1] + sv16[2];
        sv16[4] = w0_c1 + -1 * sv16[3];
        sv16[5] = J_c0 * J_c3;
        sv16[6] = J_c1 * J_c2;
        sv16[7] = sv16[5] + -1 * sv16[6];
        sv16[8] = J_c0 / sv16[7];
        sv16[9] = w0_d1_c0 * sv16[8];
        sv16[10] = -1 * J_c1 / sv16[7];
        sv16[11] = w0_d0_c0 * sv16[10];
        sv16[12] = sv16[9] + sv16[11];
        sv16[13] = sv16[12] * sv16[8];
        sv16[14] = sv16[12] * sv16[10];
        sv16[15] = J_c3 / sv16[7];
        sv16[16] = w0_d0_c0 * sv16[15];
        sv16[17] = -1 * J_c2 / sv16[7];
        sv16[18] = w0_d1_c0 * sv16[17];
        sv16[19] = sv16[16] + sv16[18];
        sv16[20] = sv16[19] * sv16[17];
        sv16[21] = sv16[19] * sv16[15];
        sv16[22] = sv16[13] + sv16[20];
        sv16[23] = sv16[21] + sv16[14];
        sv16[24] = sv16[22] * w[2][0];
        sv16[25] = sv16[23] * w[2][0];
        sv16[26] = w1_d1_c1 * sv16[8];
        sv16[27] = w1_d0_c1 * sv16[10];
        sv16[28] = sv16[26] + sv16[27];
        sv16[29] = sv16[28] * (1 + -1 * w[4][0]);
        sv16[30] = w0_d1_c1 * sv16[8];
        sv16[31] = w0_d0_c1 * sv16[10];
        sv16[32] = sv16[30] + sv16[31];
        sv16[33] = sv16[32] * w[4][0];
        sv16[34] = sv16[29] + sv16[33];
        sv16[35] = sv16[34] * sv16[8];
        sv16[36] = sv16[34] * sv16[10];
        sv16[37] = w1_d0_c1 * sv16[15];
        sv16[38] = w1_d1_c1 * sv16[17];
        sv16[39] = sv16[37] + sv16[38];
        sv16[40] = sv16[39] * (1 + -1 * w[4][0]);
        sv16[41] = w0_d0_c1 * sv16[15];
        sv16[42] = w0_d1_c1 * sv16[17];
        sv16[43] = sv16[41] + sv16[42];
        sv16[44] = sv16[43] * w[4][0];
        sv16[45] = sv16[40] + sv16[44];
        sv16[46] = sv16[45] * sv16[17];
        sv16[47] = sv16[45] * sv16[15];
        sv16[48] = sv16[35] + sv16[46];
        sv16[49] = sv16[47] + sv16[36];
        sv16[50] = sv16[48] * w[3][0];
        sv16[51] = sv16[49] * w[3][0];
        sv16[52] = std::abs(sv16[7]);
        sv16[53] = sv16[0] * sv16[52];
        sv16[54] = sv16[4] * sv16[52];
        sv16[55] = -1 * sv16[24] * sv16[52];
        sv16[56] = -1 * sv16[25] * sv16[52];
        sv16[57] = sv16[50] * sv16[52];
        sv16[58] = sv16[51] * sv16[52];
        const double fw0 = sv16[53] * weights16[iq];
        for (int i = 0; i < 4; ++i)
            BF0[i] += fw0 * FE19_C0_Q16[0][iq][i];
        const double fw1 = sv16[58] * weights16[iq];
        for (int i = 0; i < 4; ++i)
            BF1[i] += fw1 * FE19_C0_D10_Q16[0][iq][i];
        const double fw2 = sv16[57] * weights16[iq];
        for (int i = 0; i < 4; ++i)
            BF2[i] += fw2 * FE19_C0_D01_Q16[0][iq][i];
        const double fw3 = sv16[54] * weights16[iq];
        for (int i = 0; i < 4; ++i)
            BF3[i] += fw3 * FE19_C0_Q16[0][iq][i];
        const double fw4 = sv16[56] * weights16[iq];
        for (int i = 0; i < 4; ++i)
            BF4[i] += fw4 * FE19_C0_D10_Q16[0][iq][i];
        const double fw5 = sv16[55] * weights16[iq];
        for (int i = 0; i < 4; ++i)
            BF5[i] += fw5 * FE19_C0_D01_Q16[0][iq][i];
    }
    std::fill(A, A + 8, 0.0);
    for (int i = 0; i < 4; ++i)
        A[i] += BF0[i] + BF1[i] + BF2[i];
    for (int i = 0; i < 4; ++i)
        A[i + 4] += BF3[i] + BF4[i] + BF5[i];
}


cahnhilliard2d_cell_integral_1_otherwise::cahnhilliard2d_cell_integral_1_otherwise() : ufc::cell_integral()
{

}

cahnhilliard2d_cell_integral_1_otherwise::~cahnhilliard2d_cell_integral_1_otherwise()
{

}

const std::vector<bool> & cahnhilliard2d_cell_integral_1_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true});
return enabled;
}

void cahnhilliard2d_cell_integral_1_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation,
                                    std::size_t local_facet) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 6
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights16[16] = { 0.03025074832140047, 0.05671296296296294, 0.05671296296296294, 0.03025074832140047, 0.05671296296296294, 0.1063233257526736, 0.1063233257526736, 0.05671296296296294, 0.05671296296296294, 0.1063233257526736, 0.1063233257526736, 0.05671296296296294, 0.03025074832140047, 0.05671296296296294, 0.05671296296296294, 0.03025074832140047 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE17_C0_D01_Q16[1][16][4] =
        { { { -0.9305681557970262, 0.9305681557970262, -0.06943184420297371, 0.06943184420297371 },
            { -0.9305681557970262, 0.9305681557970262, -0.06943184420297371, 0.06943184420297371 },
            { -0.9305681557970262, 0.9305681557970262, -0.06943184420297371, 0.06943184420297371 },
            { -0.9305681557970262, 0.9305681557970262, -0.06943184420297371, 0.06943184420297371 },
            { -0.6699905217924281, 0.6699905217924281, -0.3300094782075719, 0.3300094782075719 },
            { -0.6699905217924281, 0.6699905217924281, -0.3300094782075719, 0.3300094782075719 },
            { -0.6699905217924281, 0.6699905217924281, -0.3300094782075719, 0.3300094782075719 },
            { -0.6699905217924281, 0.6699905217924281, -0.3300094782075719, 0.3300094782075719 },
            { -0.3300094782075719, 0.3300094782075719, -0.6699905217924281, 0.6699905217924281 },
            { -0.3300094782075719, 0.3300094782075719, -0.6699905217924281, 0.6699905217924281 },
            { -0.3300094782075719, 0.3300094782075719, -0.6699905217924281, 0.6699905217924281 },
            { -0.3300094782075719, 0.3300094782075719, -0.6699905217924281, 0.6699905217924281 },
            { -0.06943184420297371, 0.06943184420297371, -0.9305681557970262, 0.9305681557970262 },
            { -0.06943184420297371, 0.06943184420297371, -0.9305681557970262, 0.9305681557970262 },
            { -0.06943184420297371, 0.06943184420297371, -0.9305681557970262, 0.9305681557970262 },
            { -0.06943184420297371, 0.06943184420297371, -0.9305681557970262, 0.9305681557970262 } } };
    alignas(32) static const double FE17_C0_D10_Q16[1][16][4] =
        { { { -0.9305681557970262, -0.06943184420297371, 0.9305681557970262, 0.06943184420297371 },
            { -0.6699905217924281, -0.3300094782075719, 0.6699905217924281, 0.3300094782075719 },
            { -0.3300094782075719, -0.6699905217924281, 0.3300094782075719, 0.6699905217924281 },
            { -0.06943184420297371, -0.9305681557970262, 0.06943184420297371, 0.9305681557970262 },
            { -0.9305681557970262, -0.06943184420297371, 0.9305681557970262, 0.06943184420297371 },
            { -0.6699905217924281, -0.3300094782075719, 0.6699905217924281, 0.3300094782075719 },
            { -0.3300094782075719, -0.6699905217924281, 0.3300094782075719, 0.6699905217924281 },
            { -0.06943184420297371, -0.9305681557970262, 0.06943184420297371, 0.9305681557970262 },
            { -0.9305681557970262, -0.06943184420297371, 0.9305681557970262, 0.06943184420297371 },
            { -0.6699905217924281, -0.3300094782075719, 0.6699905217924281, 0.3300094782075719 },
            { -0.3300094782075719, -0.6699905217924281, 0.3300094782075719, 0.6699905217924281 },
            { -0.06943184420297371, -0.9305681557970262, 0.06943184420297371, 0.9305681557970262 },
            { -0.9305681557970262, -0.06943184420297371, 0.9305681557970262, 0.06943184420297371 },
            { -0.6699905217924281, -0.3300094782075719, 0.6699905217924281, 0.3300094782075719 },
            { -0.3300094782075719, -0.6699905217924281, 0.3300094782075719, 0.6699905217924281 },
            { -0.06943184420297371, -0.9305681557970262, 0.06943184420297371, 0.9305681557970262 } } };
    alignas(32) static const double FE17_C0_Q16[1][16][4] =
        { { { 0.8659570925834785, 0.06461106321354769, 0.06461106321354769, 0.004820780989426014 },
            { 0.6234718442658671, 0.3070963115311591, 0.04651867752656094, 0.02291316667641278 },
            { 0.3070963115311591, 0.6234718442658671, 0.02291316667641278, 0.04651867752656094 },
            { 0.06461106321354769, 0.8659570925834785, 0.004820780989426014, 0.06461106321354769 },
            { 0.6234718442658671, 0.04651867752656094, 0.3070963115311591, 0.02291316667641278 },
            { 0.4488872992916901, 0.221103222500738, 0.221103222500738, 0.1089062557068338 },
            { 0.221103222500738, 0.4488872992916901, 0.1089062557068338, 0.221103222500738 },
            { 0.04651867752656094, 0.6234718442658671, 0.02291316667641278, 0.3070963115311591 },
            { 0.3070963115311591, 0.02291316667641278, 0.6234718442658671, 0.04651867752656094 },
            { 0.221103222500738, 0.1089062557068338, 0.4488872992916901, 0.221103222500738 },
            { 0.1089062557068338, 0.221103222500738, 0.221103222500738, 0.4488872992916901 },
            { 0.02291316667641278, 0.3070963115311591, 0.04651867752656094, 0.6234718442658671 },
            { 0.06461106321354769, 0.004820780989426014, 0.8659570925834785, 0.06461106321354769 },
            { 0.04651867752656094, 0.02291316667641278, 0.6234718442658671, 0.3070963115311591 },
            { 0.02291316667641278, 0.04651867752656094, 0.3070963115311591, 0.6234718442658671 },
            { 0.004820780989426014, 0.06461106321354769, 0.06461106321354769, 0.8659570925834785 } } };
    alignas(32) double BF0[4][4] = {};
    alignas(32) double BF1[4][4] = {};
    alignas(32) double BF2[4][4] = {};
    alignas(32) double BF3[4][4] = {};
    alignas(32) double BF4[4][4] = {};
    alignas(32) double BF5[4][4] = {};
    alignas(32) double BF6[4][4] = {};
    alignas(32) double BF7[4][4] = {};
    alignas(32) double BF8[4][4] = {};
    alignas(32) double BF9[4][4] = {};
    for (int iq = 0; iq < 16; ++iq)
    {
        // Quadrature loop body setup (num_points=16)
        // Unstructured varying computations for num_points=16
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 4; ++ic)
            w0_c0 += w[0][ic] * FE17_C0_Q16[0][iq][ic];
        const double J_c0 = coordinate_dofs[0] * FE17_C0_D10_Q16[0][iq][0] + coordinate_dofs[2] * FE17_C0_D10_Q16[0][iq][1] + coordinate_dofs[4] * FE17_C0_D10_Q16[0][iq][2] + coordinate_dofs[6] * FE17_C0_D10_Q16[0][iq][3];
        const double J_c3 = coordinate_dofs[1] * FE17_C0_D01_Q16[0][iq][0] + coordinate_dofs[3] * FE17_C0_D01_Q16[0][iq][1] + coordinate_dofs[5] * FE17_C0_D01_Q16[0][iq][2] + coordinate_dofs[7] * FE17_C0_D01_Q16[0][iq][3];
        const double J_c1 = coordinate_dofs[0] * FE17_C0_D01_Q16[0][iq][0] + coordinate_dofs[2] * FE17_C0_D01_Q16[0][iq][1] + coordinate_dofs[4] * FE17_C0_D01_Q16[0][iq][2] + coordinate_dofs[6] * FE17_C0_D01_Q16[0][iq][3];
        const double J_c2 = coordinate_dofs[1] * FE17_C0_D10_Q16[0][iq][0] + coordinate_dofs[3] * FE17_C0_D10_Q16[0][iq][1] + coordinate_dofs[5] * FE17_C0_D10_Q16[0][iq][2] + coordinate_dofs[7] * FE17_C0_D10_Q16[0][iq][3];
        alignas(32) double sv16[52];
        sv16[0] = -2.0 * (1 + -1 * w0_c0) * (100 * (2.0 * w0_c0));
        sv16[1] = sv16[0] + 2.0 * (100 * std::pow(w0_c0, 2));
        sv16[2] = sv16[0] + 200.0 * std::pow(1 + -1 * w0_c0, 2);
        sv16[3] = sv16[1] + sv16[2];
        sv16[4] = J_c0 * J_c3;
        sv16[5] = J_c1 * J_c2;
        sv16[6] = sv16[4] + -1 * sv16[5];
        sv16[7] = J_c0 / sv16[6];
        sv16[8] = -1 * J_c1 / sv16[6];
        sv16[9] = sv16[7] * sv16[7];
        sv16[10] = sv16[7] * sv16[8];
        sv16[11] = sv16[8] * sv16[8];
        sv16[12] = J_c3 / sv16[6];
        sv16[13] = -1 * J_c2 / sv16[6];
        sv16[14] = sv16[13] * sv16[13];
        sv16[15] = sv16[12] * sv16[13];
        sv16[16] = sv16[12] * sv16[12];
        sv16[17] = sv16[9] + sv16[14];
        sv16[18] = sv16[10] + sv16[15];
        sv16[19] = sv16[16] + sv16[11];
        sv16[20] = sv16[17] * w[1][0];
        sv16[21] = sv16[18] * w[1][0];
        sv16[22] = sv16[19] * w[1][0];
        sv16[23] = sv16[7] * w[3][0];
        sv16[24] = sv16[8] * w[3][0];
        sv16[25] = sv16[23] * sv16[7];
        sv16[26] = sv16[24] * sv16[7];
        sv16[27] = sv16[23] * sv16[8];
        sv16[28] = sv16[24] * sv16[8];
        sv16[29] = sv16[13] * w[3][0];
        sv16[30] = sv16[12] * w[3][0];
        sv16[31] = sv16[29] * sv16[13];
        sv16[32] = sv16[30] * sv16[13];
        sv16[33] = sv16[29] * sv16[12];
        sv16[34] = sv16[30] * sv16[12];
        sv16[35] = sv16[25] + sv16[31];
        sv16[36] = sv16[26] + sv16[32];
        sv16[37] = sv16[33] + sv16[27];
        sv16[38] = sv16[34] + sv16[28];
        sv16[39] = sv16[35] * w[2][0];
        sv16[40] = sv16[36] * w[2][0];
        sv16[41] = sv16[37] * w[2][0];
        sv16[42] = sv16[38] * w[2][0];
        sv16[43] = std::abs(sv16[6]);
        sv16[44] = -1 * sv16[3] * sv16[43];
        sv16[45] = -1 * sv16[20] * sv16[43];
        sv16[46] = -1 * sv16[21] * sv16[43];
        sv16[47] = -1 * sv16[22] * sv16[43];
        sv16[48] = sv16[39] * sv16[43];
        sv16[49] = sv16[40] * sv16[43];
        sv16[50] = sv16[41] * sv16[43];
        sv16[51] = sv16[42] * sv16[43];
        const double fw0 = sv16[43] * weights16[iq];
        alignas(32) double TF0[4];
        for (int i = 0; i < 4; ++i)
            TF0[i] = fw0 * FE17_C0_Q16[0][iq][i];
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                BF0[i][j] += TF0[i] * FE17_C0_Q16[0][iq][j];
        const double fw1 = sv16[51] * weights16[iq];
        alignas(32) double TF1[4];
        for (int i = 0; i < 4; ++i)
            TF1[i] = fw1 * FE17_C0_D10_Q16[0][iq][i];
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                BF1[i][j] += TF1[i] * FE17_C0_D10_Q16[0][iq][j];
        const double fw2 = sv16[50] * weights16[iq];
        alignas(32) double TF2[4];
        for (int i = 0; i < 4; ++i)
            TF2[i] = fw2 * FE17_C0_D10_Q16[0][iq][i];
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                BF2[i][j] += TF2[i] * FE17_C0_D01_Q16[0][iq][j];
        const double fw3 = sv16[49] * weights16[iq];
        alignas(32) double TF3[4];
        for (int i = 0; i < 4; ++i)
            TF3[i] = fw3 * FE17_C0_D01_Q16[0][iq][i];
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                BF3[i][j] += TF3[i] * FE17_C0_D10_Q16[0][iq][j];
        const double fw4 = sv16[48] * weights16[iq];
        alignas(32) double TF4[4];
        for (int i = 0; i < 4; ++i)
            TF4[i] = fw4 * FE17_C0_D01_Q16[0][iq][i];
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                BF4[i][j] += TF4[i] * FE17_C0_D01_Q16[0][iq][j];
        const double fw5 = sv16[44] * weights16[iq];
        alignas(32) double TF5[4];
        for (int i = 0; i < 4; ++i)
            TF5[i] = fw5 * FE17_C0_Q16[0][iq][i];
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                BF5[i][j] += TF5[i] * FE17_C0_Q16[0][iq][j];
        const double fw6 = sv16[47] * weights16[iq];
        alignas(32) double TF6[4];
        for (int i = 0; i < 4; ++i)
            TF6[i] = fw6 * FE17_C0_D10_Q16[0][iq][i];
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                BF6[i][j] += TF6[i] * FE17_C0_D10_Q16[0][iq][j];
        const double fw7 = sv16[46] * weights16[iq];
        alignas(32) double TF7[4];
        for (int i = 0; i < 4; ++i)
            TF7[i] = fw7 * FE17_C0_D10_Q16[0][iq][i];
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                BF7[i][j] += TF7[i] * FE17_C0_D01_Q16[0][iq][j];
        alignas(32) double TF8[4];
        for (int i = 0; i < 4; ++i)
            TF8[i] = fw7 * FE17_C0_D01_Q16[0][iq][i];
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                BF8[i][j] += TF8[i] * FE17_C0_D10_Q16[0][iq][j];
        const double fw8 = sv16[45] * weights16[iq];
        alignas(32) double TF9[4];
        for (int i = 0; i < 4; ++i)
            TF9[i] = fw8 * FE17_C0_D01_Q16[0][iq][i];
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                BF9[i][j] += TF9[i] * FE17_C0_D01_Q16[0][iq][j];
    }
    std::fill(A, A + 64, 0.0);
    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            A[8 * i + j] += BF0[i][j];
    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            A[8 * i + (j + 4)] += BF1[i][j] + BF2[i][j] + BF3[i][j] + BF4[i][j];
    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            A[8 * (i + 4) + j] += BF5[i][j] + BF6[i][j] + BF7[i][j] + BF8[i][j] + BF9[i][j];
    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            A[8 * (i + 4) + (j + 4)] += BF0[i][j];
}


cahnhilliard2d_form_0::cahnhilliard2d_form_0() : ufc::form()
{
    // Do nothing
}

cahnhilliard2d_form_0::~cahnhilliard2d_form_0()
{
    // Do nothing
}

const char * cahnhilliard2d_form_0::signature() const
{
    return "49bcbf8415c07a7203cc2318e5a98d263e38c1fe0a7cdc3a2d8942b777f6b29865584c23c2fbe83be4f258b6815bb044fd8d7494d829e4dee03f933b10f022d1";
}

std::size_t cahnhilliard2d_form_0::rank() const
{
    return 1;
}

std::size_t cahnhilliard2d_form_0::num_coefficients() const
{
    return 5;
}

std::size_t cahnhilliard2d_form_0::original_coefficient_position(std::size_t i) const
{
    if (i >= 5)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2, 3, 4};
    return position[i];
}

ufc::finite_element * cahnhilliard2d_form_0::create_coordinate_finite_element() const
{
    return new cahnhilliard2d_finite_element_1();
}

ufc::dofmap * cahnhilliard2d_form_0::create_coordinate_dofmap() const
{
    return new cahnhilliard2d_dofmap_1();
}

ufc::coordinate_mapping * cahnhilliard2d_form_0::create_coordinate_mapping() const
{
    return new cahnhilliard2d_coordinate_mapping_1();
}

ufc::finite_element * cahnhilliard2d_form_0::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new cahnhilliard2d_finite_element_2();
    case 1:
        return new cahnhilliard2d_finite_element_2();
    case 2:
        return new cahnhilliard2d_finite_element_2();
    case 3:
        return new cahnhilliard2d_finite_element_3();
    case 4:
        return new cahnhilliard2d_finite_element_3();
    case 5:
        return new cahnhilliard2d_finite_element_3();
    default:
        return nullptr;
    }
}

ufc::dofmap * cahnhilliard2d_form_0::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new cahnhilliard2d_dofmap_2();
    case 1:
        return new cahnhilliard2d_dofmap_2();
    case 2:
        return new cahnhilliard2d_dofmap_2();
    case 3:
        return new cahnhilliard2d_dofmap_3();
    case 4:
        return new cahnhilliard2d_dofmap_3();
    case 5:
        return new cahnhilliard2d_dofmap_3();
    default:
        return nullptr;
    }
}

std::size_t cahnhilliard2d_form_0::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_0::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_0::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_0::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_0::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_0::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_0::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_0::max_overlap_subdomain_id() const
{
    return 0;
}

bool cahnhilliard2d_form_0::has_cell_integrals() const
{
    return true;
}

bool cahnhilliard2d_form_0::has_exterior_facet_integrals() const
{
    return false;
}

bool cahnhilliard2d_form_0::has_interior_facet_integrals() const
{
    return false;
}

bool cahnhilliard2d_form_0::has_vertex_integrals() const
{
    return false;
}

bool cahnhilliard2d_form_0::has_custom_integrals() const
{
    return false;
}

bool cahnhilliard2d_form_0::has_cutcell_integrals() const
{
    return false;
}

bool cahnhilliard2d_form_0::has_interface_integrals() const
{
    return false;
}

bool cahnhilliard2d_form_0::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * cahnhilliard2d_form_0::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * cahnhilliard2d_form_0::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * cahnhilliard2d_form_0::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * cahnhilliard2d_form_0::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * cahnhilliard2d_form_0::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * cahnhilliard2d_form_0::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * cahnhilliard2d_form_0::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * cahnhilliard2d_form_0::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * cahnhilliard2d_form_0::create_default_cell_integral() const
{
    return new cahnhilliard2d_cell_integral_0_otherwise();
}

ufc::exterior_facet_integral * cahnhilliard2d_form_0::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * cahnhilliard2d_form_0::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * cahnhilliard2d_form_0::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * cahnhilliard2d_form_0::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * cahnhilliard2d_form_0::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * cahnhilliard2d_form_0::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * cahnhilliard2d_form_0::create_default_overlap_integral() const
{
    return nullptr;
}


cahnhilliard2d_form_1::cahnhilliard2d_form_1() : ufc::form()
{
    // Do nothing
}

cahnhilliard2d_form_1::~cahnhilliard2d_form_1()
{
    // Do nothing
}

const char * cahnhilliard2d_form_1::signature() const
{
    return "5402efc0bbe06c33995a2fe2ec7af79465351b335d188b1ec75adf46de14bbd090df52156857c9547f727c7d1d4b318f6640e1d07b90f771301dbf31a305f255";
}

std::size_t cahnhilliard2d_form_1::rank() const
{
    return 2;
}

std::size_t cahnhilliard2d_form_1::num_coefficients() const
{
    return 4;
}

std::size_t cahnhilliard2d_form_1::original_coefficient_position(std::size_t i) const
{
    if (i >= 4)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 2, 3, 4};
    return position[i];
}

ufc::finite_element * cahnhilliard2d_form_1::create_coordinate_finite_element() const
{
    return new cahnhilliard2d_finite_element_1();
}

ufc::dofmap * cahnhilliard2d_form_1::create_coordinate_dofmap() const
{
    return new cahnhilliard2d_dofmap_1();
}

ufc::coordinate_mapping * cahnhilliard2d_form_1::create_coordinate_mapping() const
{
    return new cahnhilliard2d_coordinate_mapping_1();
}

ufc::finite_element * cahnhilliard2d_form_1::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new cahnhilliard2d_finite_element_2();
    case 1:
        return new cahnhilliard2d_finite_element_2();
    case 2:
        return new cahnhilliard2d_finite_element_2();
    case 3:
        return new cahnhilliard2d_finite_element_3();
    case 4:
        return new cahnhilliard2d_finite_element_3();
    case 5:
        return new cahnhilliard2d_finite_element_3();
    default:
        return nullptr;
    }
}

ufc::dofmap * cahnhilliard2d_form_1::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new cahnhilliard2d_dofmap_2();
    case 1:
        return new cahnhilliard2d_dofmap_2();
    case 2:
        return new cahnhilliard2d_dofmap_2();
    case 3:
        return new cahnhilliard2d_dofmap_3();
    case 4:
        return new cahnhilliard2d_dofmap_3();
    case 5:
        return new cahnhilliard2d_dofmap_3();
    default:
        return nullptr;
    }
}

std::size_t cahnhilliard2d_form_1::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_1::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_1::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_1::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_1::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_1::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_1::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t cahnhilliard2d_form_1::max_overlap_subdomain_id() const
{
    return 0;
}

bool cahnhilliard2d_form_1::has_cell_integrals() const
{
    return true;
}

bool cahnhilliard2d_form_1::has_exterior_facet_integrals() const
{
    return false;
}

bool cahnhilliard2d_form_1::has_interior_facet_integrals() const
{
    return false;
}

bool cahnhilliard2d_form_1::has_vertex_integrals() const
{
    return false;
}

bool cahnhilliard2d_form_1::has_custom_integrals() const
{
    return false;
}

bool cahnhilliard2d_form_1::has_cutcell_integrals() const
{
    return false;
}

bool cahnhilliard2d_form_1::has_interface_integrals() const
{
    return false;
}

bool cahnhilliard2d_form_1::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * cahnhilliard2d_form_1::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * cahnhilliard2d_form_1::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * cahnhilliard2d_form_1::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * cahnhilliard2d_form_1::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * cahnhilliard2d_form_1::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * cahnhilliard2d_form_1::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * cahnhilliard2d_form_1::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * cahnhilliard2d_form_1::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * cahnhilliard2d_form_1::create_default_cell_integral() const
{
    return new cahnhilliard2d_cell_integral_1_otherwise();
}

ufc::exterior_facet_integral * cahnhilliard2d_form_1::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * cahnhilliard2d_form_1::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * cahnhilliard2d_form_1::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * cahnhilliard2d_form_1::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * cahnhilliard2d_form_1::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * cahnhilliard2d_form_1::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * cahnhilliard2d_form_1::create_default_overlap_integral() const
{
    return nullptr;
}

