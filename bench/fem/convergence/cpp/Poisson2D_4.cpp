// This code conforms with the UFC specification version 2018.1.0
// and was automatically generated by FFC version 2019.2.0.dev0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
//
// This code was generated with the following parameters:
//

//  add_tabulate_tensor_timing:     False
//  convert_exceptions_to_warnings: False
//  cpp_optimize:                   True
//  cpp_optimize_flags:             '-O2'
//  epsilon:                        1e-14
//  error_control:                  False
//  external_include_dirs:          ''
//  external_includes:              ''
//  external_libraries:             ''
//  external_library_dirs:          ''
//  form_postfix:                   True
//  format:                         'dolfin'
//  generate_dummy_tabulate_tensor: False
//  max_signature_length:           0
//  optimize:                       True
//  precision:                      None
//  quadrature_degree:              None
//  quadrature_rule:                None
//  representation:                 'auto'
//  split:                          True

#include "Poisson2D_4.h"

poisson2d_4_finite_element_0::poisson2d_4_finite_element_0() : ufc::finite_element()
{
    // Do nothing
}

poisson2d_4_finite_element_0::~poisson2d_4_finite_element_0()
{
    // Do nothing
}

const char * poisson2d_4_finite_element_0::signature() const
{
    return "FiniteElement('Lagrange', triangle, 1)";
}

ufc::shape poisson2d_4_finite_element_0::cell_shape() const
{
    return ufc::shape::triangle;
}

std::size_t poisson2d_4_finite_element_0::topological_dimension() const
{
    return 2;
}

std::size_t poisson2d_4_finite_element_0::geometric_dimension() const
{
    return 2;
}

std::size_t poisson2d_4_finite_element_0::space_dimension() const
{
    return 3;
}

std::size_t poisson2d_4_finite_element_0::value_rank() const
{
    return 0;
}

std::size_t poisson2d_4_finite_element_0::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t poisson2d_4_finite_element_0::value_size() const
{
    return 1;
}

std::size_t poisson2d_4_finite_element_0::reference_value_rank() const
{
    return 0;
}

std::size_t poisson2d_4_finite_element_0::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t poisson2d_4_finite_element_0::reference_value_size() const
{
    return 1;
}

std::size_t poisson2d_4_finite_element_0::degree() const
{
    return 1;
}

const char * poisson2d_4_finite_element_0::family() const
{
    return "Lagrange";
}

void poisson2d_4_finite_element_0::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][3] = { { 0.4714045207910316, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    for (std::size_t k = 0; k < num_points * 3; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip + 2] += coefficients2[0][r] * basisvalues1[r];
    }
}

void poisson2d_4_finite_element_0::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 3 * num_derivatives, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    static const double coefficients0[1][3] = { { 0.4714045207910316, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    const std::size_t reference_offset[3] = {};
    const std::size_t num_components[3] = { 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Loop over all dofs
        for (std::size_t i = 0; i < 3; ++i)
        {
            double derivatives[2] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[3 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void poisson2d_4_finite_element_0::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    std::fill_n(values, num_points * 3 * num_derivatives, 0.0);
    const std::size_t reference_offsets[3] = {};
    const std::size_t physical_offsets[3] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[2][2];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 3; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[3 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[3 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void poisson2d_4_finite_element_0::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[3];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[3];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
}

void poisson2d_4_finite_element_0::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold value of a single dof.
    double dof_values = 0.0;
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 3; ++r)
    {
        evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
        values[r] = dof_values;
    }
}

void poisson2d_4_finite_element_0::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    // Declare transformation matrix
    double transform[2][2] =
        { { 1.0, 1.0 },
          { 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void poisson2d_4_finite_element_0::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, num_derivatives * 3, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 3; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < num_derivatives; ++s)
            values[num_derivatives * r + s] = dof_values[s];
    }
}

double poisson2d_4_finite_element_0::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
}

void poisson2d_4_finite_element_0::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
}

void poisson2d_4_finite_element_0::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
}

void poisson2d_4_finite_element_0::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
}

void poisson2d_4_finite_element_0::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[6] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 6, reference_dof_coordinates);
}

std::size_t poisson2d_4_finite_element_0::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * poisson2d_4_finite_element_0::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * poisson2d_4_finite_element_0::create() const
{
    return new poisson2d_4_finite_element_0();
}


poisson2d_4_finite_element_1::poisson2d_4_finite_element_1() : ufc::finite_element()
{
    // Do nothing
}

poisson2d_4_finite_element_1::~poisson2d_4_finite_element_1()
{
    // Do nothing
}

const char * poisson2d_4_finite_element_1::signature() const
{
    return "VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
}

ufc::shape poisson2d_4_finite_element_1::cell_shape() const
{
    return ufc::shape::triangle;
}

std::size_t poisson2d_4_finite_element_1::topological_dimension() const
{
    return 2;
}

std::size_t poisson2d_4_finite_element_1::geometric_dimension() const
{
    return 2;
}

std::size_t poisson2d_4_finite_element_1::space_dimension() const
{
    return 6;
}

std::size_t poisson2d_4_finite_element_1::value_rank() const
{
    return 1;
}

std::size_t poisson2d_4_finite_element_1::value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t poisson2d_4_finite_element_1::value_size() const
{
    return 2;
}

std::size_t poisson2d_4_finite_element_1::reference_value_rank() const
{
    return 1;
}

std::size_t poisson2d_4_finite_element_1::reference_value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t poisson2d_4_finite_element_1::reference_value_size() const
{
    return 2;
}

std::size_t poisson2d_4_finite_element_1::degree() const
{
    return 1;
}

const char * poisson2d_4_finite_element_1::family() const
{
    return "Lagrange";
}

void poisson2d_4_finite_element_1::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][3] = { { 0.4714045207910316, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    for (std::size_t k = 0; k < num_points * 6 * 2; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 3 + 1] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 4 + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 5 + 1] += coefficients2[0][r] * basisvalues1[r];
    }
}

void poisson2d_4_finite_element_1::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 6 * num_derivatives * 2, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    static const double coefficients0[1][3] = { { 0.4714045207910316, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    const std::size_t reference_offset[6] = { 0, 0, 0, 1, 1, 1 };
    const std::size_t num_components[6] = { 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Loop over all dofs
        for (std::size_t i = 0; i < 6; ++i)
        {
            double derivatives[2] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * i + 2 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void poisson2d_4_finite_element_1::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    std::fill_n(values, num_points * 6 * num_derivatives * 2, 0.0);
    const std::size_t reference_offsets[6] = { 0, 0, 0, 1, 1, 1 };
    const std::size_t physical_offsets[6] = { 0, 0, 0, 1, 1, 1 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[2][2];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 6; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void poisson2d_4_finite_element_1::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[12];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[12];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 2; ++k)
        values[k] = physical_values[2 * i + k];
}

void poisson2d_4_finite_element_1::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2; ++s)
            values[r * 2 + s] = dof_values[s];
    }
}

void poisson2d_4_finite_element_1::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, 2 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    // Declare transformation matrix
    double transform[2][2] =
        { { 1.0, 1.0 },
          { 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void poisson2d_4_finite_element_1::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, 2 * num_derivatives * 6, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[4] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2 * num_derivatives; ++s)
            values[2 * num_derivatives * r + s] = dof_values[s];
    }
}

double poisson2d_4_finite_element_1::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 4:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 5:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    }
    return 0.0;
}

void poisson2d_4_finite_element_1::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[1];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
}

void poisson2d_4_finite_element_1::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[3];
    vertex_values[3] = dof_values[4];
    vertex_values[5] = dof_values[5];
}

void poisson2d_4_finite_element_1::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = coordinate_dofs[0];
    dof_coordinates[2 * 3 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 4] = coordinate_dofs[2];
    dof_coordinates[2 * 4 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 5] = coordinate_dofs[4];
    dof_coordinates[2 * 5 + 1] = coordinate_dofs[5];
}

void poisson2d_4_finite_element_1::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[12] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 12, reference_dof_coordinates);
}

std::size_t poisson2d_4_finite_element_1::num_sub_elements() const
{
    return 2;
}

ufc::finite_element * poisson2d_4_finite_element_1::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new poisson2d_4_finite_element_0();
    case 1:
        return new poisson2d_4_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::finite_element * poisson2d_4_finite_element_1::create() const
{
    return new poisson2d_4_finite_element_1();
}


poisson2d_4_finite_element_2::poisson2d_4_finite_element_2() : ufc::finite_element()
{
    // Do nothing
}

poisson2d_4_finite_element_2::~poisson2d_4_finite_element_2()
{
    // Do nothing
}

const char * poisson2d_4_finite_element_2::signature() const
{
    return "FiniteElement('Lagrange', triangle, 4)";
}

ufc::shape poisson2d_4_finite_element_2::cell_shape() const
{
    return ufc::shape::triangle;
}

std::size_t poisson2d_4_finite_element_2::topological_dimension() const
{
    return 2;
}

std::size_t poisson2d_4_finite_element_2::geometric_dimension() const
{
    return 2;
}

std::size_t poisson2d_4_finite_element_2::space_dimension() const
{
    return 15;
}

std::size_t poisson2d_4_finite_element_2::value_rank() const
{
    return 0;
}

std::size_t poisson2d_4_finite_element_2::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t poisson2d_4_finite_element_2::value_size() const
{
    return 1;
}

std::size_t poisson2d_4_finite_element_2::reference_value_rank() const
{
    return 0;
}

std::size_t poisson2d_4_finite_element_2::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t poisson2d_4_finite_element_2::reference_value_size() const
{
    return 1;
}

std::size_t poisson2d_4_finite_element_2::degree() const
{
    return 4;
}

const char * poisson2d_4_finite_element_2::family() const
{
    return "Lagrange";
}

void poisson2d_4_finite_element_2::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][15] = { { 0.0, -0.041239304942116146, -0.0238095238095238, 0.02898002949762787, 0.02244783432338248, 0.012960263189329005, -0.0395942580610999, -0.03346325566315744, -0.02592052637865797, -0.014965222882254969, 0.03212472543663115, 0.02833134481385228, 0.023944356611607938, 0.018547218878481833, 0.010708241812210372 } };
    static const double coefficients1[1][15] = { { 0.0, 0.04123930494211611, -0.023809523809523784, 0.02898002949762787, -0.022447834323382453, 0.012960263189329, 0.03959425806109992, -0.03346325566315744, 0.025920526378657965, -0.014965222882254981, 0.03212472543663115, -0.028331344813852296, 0.023944356611607945, -0.018547218878481826, 0.010708241812210383 } };
    static const double coefficients2[1][15] = { { 0.0, 0.0, 0.047619047619047616, 0.0, 0.0, 0.038880789567986934, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.05354120906105193 } };
    static const double coefficients3[1][15] = { { 0.12570787221094165, 0.1319657758147716, -0.025396825396825355, 0.13910414158861367, -0.07183306983482386, 0.03110463165438956, 0.06335081289775986, 0.026770604530525936, -0.06220926330877912, 0.0478887132232159, 0.0, 0.05666268962770458, -0.08380524814062787, 0.08346248495316816, -0.05354120906105191 } };
    static const double coefficients4[1][15] = { { -0.03142696805273556, 0.010997147984564411, 0.006349206349206314, 0.0, 0.18856180831641273, -0.16329931618554522, 0.0, 0.09369711585684086, 0.0, -0.041902624070313914, 0.0, 0.0, 0.08380524814062786, -0.13910414158861362, 0.10708241812210385 } };
    static const double coefficients5[1][15] = { { 0.12570787221094176, 0.04398859193825711, 0.12698412698412703, 0.0, 0.03591653491741193, 0.1555231582719478, 0.0, 0.0, 0.10368210551463192, -0.011972178305804009, 0.0, 0.0, 0.0, 0.09273609439240907, -0.10708241812210383 } };
    static const double coefficients6[1][15] = { { 0.1257078722109417, -0.1319657758147716, -0.025396825396825393, 0.13910414158861367, 0.07183306983482389, 0.03110463165438956, -0.06335081289775987, 0.026770604530525956, 0.06220926330877912, 0.04788871322321592, 0.0, -0.05666268962770459, -0.08380524814062787, -0.08346248495316817, -0.05354120906105193 } };
    static const double coefficients7[1][15] = { { -0.03142696805273538, -0.010997147984564368, 0.006349206349206332, 0.0, -0.18856180831641273, -0.16329931618554525, 0.0, 0.09369711585684083, 0.0, -0.041902624070313914, 0.0, 0.0, 0.0838052481406279, 0.13910414158861362, 0.10708241812210385 } };
    static const double coefficients8[1][15] = { { 0.1257078722109417, -0.04398859193825721, 0.12698412698412698, 0.0, -0.03591653491741196, 0.15552315827194782, 0.0, 0.0, -0.1036821055146319, -0.011972178305804009, 0.0, 0.0, 0.0, -0.0927360943924091, -0.10708241812210383 } };
    static const double coefficients9[1][15] = { { 0.12570787221094154, -0.08797718387651446, -0.10158730158730156, 0.09273609439240907, 0.10774960475223581, 0.07257747386024228, 0.07918851612219979, -0.013385302265262968, -0.051841052757315924, -0.041902624070313914, -0.12849890174652462, -0.05666268962770459, -0.01197217830580395, 0.009273609439240903, 0.010708241812210388 } };
    static const double coefficients10[1][15] = { { -0.03142696805273548, 0.0, -0.01269841269841278, -0.24343224778007383, 0.0, 0.054433105395181716, 0.0, 0.09369711585684085, 0.0, -0.041902624070313914, 0.1927483526197869, 0.0, -0.023944356611607952, 0.0, 0.0107082418122104 } };
    static const double coefficients11[1][15] = { { 0.12570787221094165, 0.08797718387651449, -0.10158730158730152, 0.09273609439240907, -0.10774960475223581, 0.07257747386024233, -0.07918851612219986, -0.013385302265262985, 0.05184105275731595, -0.041902624070313914, -0.12849890174652456, 0.05666268962770458, -0.01197217830580399, -0.009273609439240904, 0.010708241812210374 } };
    static const double coefficients12[1][15] = { { 0.2514157444218837, -0.3519087355060576, -0.20317460317460315, -0.13910414158861356, -0.10774960475223581, -0.06220926330877912, 0.19005243869327956, -0.02677060453052593, 0.12441852661755823, 0.15563831797545172, 0.0, 0.16998806888311377, 0.08380524814062781, -0.02782082831772274, -0.05354120906105193 } };
    static const double coefficients13[1][15] = { { 0.25141574442188397, 0.3519087355060575, -0.20317460317460315, -0.13910414158861364, 0.10774960475223574, -0.06220926330877919, -0.19005243869327954, -0.026770604530525943, -0.12441852661755823, 0.15563831797545172, 0.0, -0.16998806888311374, 0.08380524814062784, 0.027820828317722715, -0.05354120906105189 } };
    static const double coefficients14[1][15] = { { 0.2514157444218835, 0.0, 0.4063492063492063, 0.0, 0.0, -0.18662778992633736, 0.0, -0.18739423171368175, 0.0, -0.20352703119866758, 0.0, 0.0, -0.16761049628125563, 0.0, 0.10708241812210378 } };
    for (std::size_t k = 0; k < num_points * 15; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues4[15] = {};
        basisvalues4[0] = 1.0;
        const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues4[1] = tmp1_4;
        const double tmp2_4 = (1.0 - Y[1]) / 2.0;
        const double tmp3_4 = tmp2_4 * tmp2_4;
        basisvalues4[3] = 1.5 * tmp1_4 * basisvalues4[1] - 0.5 * tmp3_4 * basisvalues4[0];
        basisvalues4[6] = 1.6666666666666667 * tmp1_4 * basisvalues4[3] - 0.6666666666666666 * tmp3_4 * basisvalues4[1];
        basisvalues4[10] = 1.75 * tmp1_4 * basisvalues4[6] - 0.75 * tmp3_4 * basisvalues4[3];
        basisvalues4[2] = (0.5 + 1.5 * Y[1]) * basisvalues4[0];
        basisvalues4[4] = (1.5 + 2.5 * Y[1]) * basisvalues4[1];
        basisvalues4[7] = (2.5 + 3.5 * Y[1]) * basisvalues4[3];
        basisvalues4[11] = (3.5 + 4.5 * Y[1]) * basisvalues4[6];
        basisvalues4[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues4[2] - 0.5555555555555556 * basisvalues4[0];
        basisvalues4[9] = (0.05 + 1.75 * Y[1]) * basisvalues4[5] - 0.7 * basisvalues4[2];
        basisvalues4[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues4[9] - 0.7714285714285715 * basisvalues4[5];
        basisvalues4[8] = (0.54 + 2.1 * Y[1]) * basisvalues4[4] - 0.56 * basisvalues4[1];
        basisvalues4[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues4[8] - 0.7142857142857143 * basisvalues4[4];
        basisvalues4[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues4[7] - 0.5510204081632653 * basisvalues4[3];
        basisvalues4[0] *= std::sqrt(0.5);
        basisvalues4[2] *= std::sqrt(1.0);
        basisvalues4[5] *= std::sqrt(1.5);
        basisvalues4[9] *= std::sqrt(2.0);
        basisvalues4[14] *= std::sqrt(2.5);
        basisvalues4[1] *= std::sqrt(3.0);
        basisvalues4[4] *= std::sqrt(4.5);
        basisvalues4[8] *= std::sqrt(6.0);
        basisvalues4[13] *= std::sqrt(7.5);
        basisvalues4[3] *= std::sqrt(7.5);
        basisvalues4[7] *= std::sqrt(10.0);
        basisvalues4[12] *= std::sqrt(12.5);
        basisvalues4[6] *= std::sqrt(14.0);
        basisvalues4[11] *= std::sqrt(17.5);
        basisvalues4[10] *= std::sqrt(22.5);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip] += coefficients0[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 1] += coefficients1[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 2] += coefficients2[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 3] += coefficients3[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 4] += coefficients4[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 5] += coefficients5[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 6] += coefficients6[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 7] += coefficients7[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 8] += coefficients8[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 9] += coefficients9[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 10] += coefficients10[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 11] += coefficients11[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 12] += coefficients12[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 13] += coefficients13[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 14] += coefficients14[0][r] * basisvalues4[r];
    }
}

void poisson2d_4_finite_element_2::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 15 * num_derivatives, 0.0);
    if (order > 4)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][15][15] =
        { { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 5.29150262212921, 0.0, -2.9933259094191693, 13.662601021279482, 0.0, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 10.954451150103328, 0.0, 0.0, -3.833259389999657, 0.0, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.73286382647968, 0.0, 3.3466401061362974, 4.3643578047198455, 0.0, -5.074680379332347, 0.0, 17.0084012854152, 0.0, 1.52127765851132, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } } };
    static const double coefficients0[1][15] = { { 0.0, -0.041239304942116146, -0.0238095238095238, 0.02898002949762787, 0.02244783432338248, 0.012960263189329005, -0.0395942580610999, -0.03346325566315744, -0.02592052637865797, -0.014965222882254969, 0.03212472543663115, 0.02833134481385228, 0.023944356611607938, 0.018547218878481833, 0.010708241812210372 } };
    static const double coefficients1[1][15] = { { 0.0, 0.04123930494211611, -0.023809523809523784, 0.02898002949762787, -0.022447834323382453, 0.012960263189329, 0.03959425806109992, -0.03346325566315744, 0.025920526378657965, -0.014965222882254981, 0.03212472543663115, -0.028331344813852296, 0.023944356611607945, -0.018547218878481826, 0.010708241812210383 } };
    static const double coefficients2[1][15] = { { 0.0, 0.0, 0.047619047619047616, 0.0, 0.0, 0.038880789567986934, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.05354120906105193 } };
    static const double coefficients3[1][15] = { { 0.12570787221094165, 0.1319657758147716, -0.025396825396825355, 0.13910414158861367, -0.07183306983482386, 0.03110463165438956, 0.06335081289775986, 0.026770604530525936, -0.06220926330877912, 0.0478887132232159, 0.0, 0.05666268962770458, -0.08380524814062787, 0.08346248495316816, -0.05354120906105191 } };
    static const double coefficients4[1][15] = { { -0.03142696805273556, 0.010997147984564411, 0.006349206349206314, 0.0, 0.18856180831641273, -0.16329931618554522, 0.0, 0.09369711585684086, 0.0, -0.041902624070313914, 0.0, 0.0, 0.08380524814062786, -0.13910414158861362, 0.10708241812210385 } };
    static const double coefficients5[1][15] = { { 0.12570787221094176, 0.04398859193825711, 0.12698412698412703, 0.0, 0.03591653491741193, 0.1555231582719478, 0.0, 0.0, 0.10368210551463192, -0.011972178305804009, 0.0, 0.0, 0.0, 0.09273609439240907, -0.10708241812210383 } };
    static const double coefficients6[1][15] = { { 0.1257078722109417, -0.1319657758147716, -0.025396825396825393, 0.13910414158861367, 0.07183306983482389, 0.03110463165438956, -0.06335081289775987, 0.026770604530525956, 0.06220926330877912, 0.04788871322321592, 0.0, -0.05666268962770459, -0.08380524814062787, -0.08346248495316817, -0.05354120906105193 } };
    static const double coefficients7[1][15] = { { -0.03142696805273538, -0.010997147984564368, 0.006349206349206332, 0.0, -0.18856180831641273, -0.16329931618554525, 0.0, 0.09369711585684083, 0.0, -0.041902624070313914, 0.0, 0.0, 0.0838052481406279, 0.13910414158861362, 0.10708241812210385 } };
    static const double coefficients8[1][15] = { { 0.1257078722109417, -0.04398859193825721, 0.12698412698412698, 0.0, -0.03591653491741196, 0.15552315827194782, 0.0, 0.0, -0.1036821055146319, -0.011972178305804009, 0.0, 0.0, 0.0, -0.0927360943924091, -0.10708241812210383 } };
    static const double coefficients9[1][15] = { { 0.12570787221094154, -0.08797718387651446, -0.10158730158730156, 0.09273609439240907, 0.10774960475223581, 0.07257747386024228, 0.07918851612219979, -0.013385302265262968, -0.051841052757315924, -0.041902624070313914, -0.12849890174652462, -0.05666268962770459, -0.01197217830580395, 0.009273609439240903, 0.010708241812210388 } };
    static const double coefficients10[1][15] = { { -0.03142696805273548, 0.0, -0.01269841269841278, -0.24343224778007383, 0.0, 0.054433105395181716, 0.0, 0.09369711585684085, 0.0, -0.041902624070313914, 0.1927483526197869, 0.0, -0.023944356611607952, 0.0, 0.0107082418122104 } };
    static const double coefficients11[1][15] = { { 0.12570787221094165, 0.08797718387651449, -0.10158730158730152, 0.09273609439240907, -0.10774960475223581, 0.07257747386024233, -0.07918851612219986, -0.013385302265262985, 0.05184105275731595, -0.041902624070313914, -0.12849890174652456, 0.05666268962770458, -0.01197217830580399, -0.009273609439240904, 0.010708241812210374 } };
    static const double coefficients12[1][15] = { { 0.2514157444218837, -0.3519087355060576, -0.20317460317460315, -0.13910414158861356, -0.10774960475223581, -0.06220926330877912, 0.19005243869327956, -0.02677060453052593, 0.12441852661755823, 0.15563831797545172, 0.0, 0.16998806888311377, 0.08380524814062781, -0.02782082831772274, -0.05354120906105193 } };
    static const double coefficients13[1][15] = { { 0.25141574442188397, 0.3519087355060575, -0.20317460317460315, -0.13910414158861364, 0.10774960475223574, -0.06220926330877919, -0.19005243869327954, -0.026770604530525943, -0.12441852661755823, 0.15563831797545172, 0.0, -0.16998806888311374, 0.08380524814062784, 0.027820828317722715, -0.05354120906105189 } };
    static const double coefficients14[1][15] = { { 0.2514157444218835, 0.0, 0.4063492063492063, 0.0, 0.0, -0.18662778992633736, 0.0, -0.18739423171368175, 0.0, -0.20352703119866758, 0.0, 0.0, -0.16761049628125563, 0.0, 0.10708241812210378 } };
    const std::size_t reference_offset[15] = {};
    const std::size_t num_components[15] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[4][16][4] =
        { { { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 0, 1, 0 },
            { 0, 1, 0, 0 },
            { 0, 1, 1, 0 },
            { 1, 0, 0, 0 },
            { 1, 0, 1, 0 },
            { 1, 1, 0, 0 },
            { 1, 1, 1, 0 },
            { 0, 0, 0, 0 },
            { 0, 0, 1, 0 },
            { 0, 1, 0, 0 },
            { 0, 1, 1, 0 },
            { 1, 0, 0, 0 },
            { 1, 0, 1, 0 },
            { 1, 1, 0, 0 },
            { 1, 1, 1, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 0, 0, 1 },
            { 0, 0, 1, 0 },
            { 0, 0, 1, 1 },
            { 0, 1, 0, 0 },
            { 0, 1, 0, 1 },
            { 0, 1, 1, 0 },
            { 0, 1, 1, 1 },
            { 1, 0, 0, 0 },
            { 1, 0, 0, 1 },
            { 1, 0, 1, 0 },
            { 1, 0, 1, 1 },
            { 1, 1, 0, 0 },
            { 1, 1, 0, 1 },
            { 1, 1, 1, 0 },
            { 1, 1, 1, 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues4[15] = {};
        basisvalues4[0] = 1.0;
        const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues4[1] = tmp1_4;
        const double tmp2_4 = (1.0 - Y[1]) / 2.0;
        const double tmp3_4 = tmp2_4 * tmp2_4;
        basisvalues4[3] = 1.5 * tmp1_4 * basisvalues4[1] - 0.5 * tmp3_4 * basisvalues4[0];
        basisvalues4[6] = 1.6666666666666667 * tmp1_4 * basisvalues4[3] - 0.6666666666666666 * tmp3_4 * basisvalues4[1];
        basisvalues4[10] = 1.75 * tmp1_4 * basisvalues4[6] - 0.75 * tmp3_4 * basisvalues4[3];
        basisvalues4[2] = (0.5 + 1.5 * Y[1]) * basisvalues4[0];
        basisvalues4[4] = (1.5 + 2.5 * Y[1]) * basisvalues4[1];
        basisvalues4[7] = (2.5 + 3.5 * Y[1]) * basisvalues4[3];
        basisvalues4[11] = (3.5 + 4.5 * Y[1]) * basisvalues4[6];
        basisvalues4[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues4[2] - 0.5555555555555556 * basisvalues4[0];
        basisvalues4[9] = (0.05 + 1.75 * Y[1]) * basisvalues4[5] - 0.7 * basisvalues4[2];
        basisvalues4[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues4[9] - 0.7714285714285715 * basisvalues4[5];
        basisvalues4[8] = (0.54 + 2.1 * Y[1]) * basisvalues4[4] - 0.56 * basisvalues4[1];
        basisvalues4[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues4[8] - 0.7142857142857143 * basisvalues4[4];
        basisvalues4[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues4[7] - 0.5510204081632653 * basisvalues4[3];
        basisvalues4[0] *= std::sqrt(0.5);
        basisvalues4[2] *= std::sqrt(1.0);
        basisvalues4[5] *= std::sqrt(1.5);
        basisvalues4[9] *= std::sqrt(2.0);
        basisvalues4[14] *= std::sqrt(2.5);
        basisvalues4[1] *= std::sqrt(3.0);
        basisvalues4[4] *= std::sqrt(4.5);
        basisvalues4[8] *= std::sqrt(6.0);
        basisvalues4[13] *= std::sqrt(7.5);
        basisvalues4[3] *= std::sqrt(7.5);
        basisvalues4[7] *= std::sqrt(10.0);
        basisvalues4[12] *= std::sqrt(12.5);
        basisvalues4[6] *= std::sqrt(14.0);
        basisvalues4[11] *= std::sqrt(17.5);
        basisvalues4[10] *= std::sqrt(22.5);
        // Loop over all dofs
        for (std::size_t i = 0; i < 15; ++i)
        {
            double derivatives[16] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients4[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients5[0][s] * aux[s];
                }
                break;
            case 6:
                // Compute reference derivatives for dof 6.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients6[0][s] * aux[s];
                }
                break;
            case 7:
                // Compute reference derivatives for dof 7.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients7[0][s] * aux[s];
                }
                break;
            case 8:
                // Compute reference derivatives for dof 8.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients8[0][s] * aux[s];
                }
                break;
            case 9:
                // Compute reference derivatives for dof 9.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients9[0][s] * aux[s];
                }
                break;
            case 10:
                // Compute reference derivatives for dof 10.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients10[0][s] * aux[s];
                }
                break;
            case 11:
                // Compute reference derivatives for dof 11.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients11[0][s] * aux[s];
                }
                break;
            case 12:
                // Compute reference derivatives for dof 12.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients12[0][s] * aux[s];
                }
                break;
            case 13:
                // Compute reference derivatives for dof 13.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients13[0][s] * aux[s];
                }
                break;
            case 14:
                // Compute reference derivatives for dof 14.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients14[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[15 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void poisson2d_4_finite_element_2::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[4][16][4] =
        { { { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 0, 1, 0 },
            { 0, 1, 0, 0 },
            { 0, 1, 1, 0 },
            { 1, 0, 0, 0 },
            { 1, 0, 1, 0 },
            { 1, 1, 0, 0 },
            { 1, 1, 1, 0 },
            { 0, 0, 0, 0 },
            { 0, 0, 1, 0 },
            { 0, 1, 0, 0 },
            { 0, 1, 1, 0 },
            { 1, 0, 0, 0 },
            { 1, 0, 1, 0 },
            { 1, 1, 0, 0 },
            { 1, 1, 1, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 0, 0, 1 },
            { 0, 0, 1, 0 },
            { 0, 0, 1, 1 },
            { 0, 1, 0, 0 },
            { 0, 1, 0, 1 },
            { 0, 1, 1, 0 },
            { 0, 1, 1, 1 },
            { 1, 0, 0, 0 },
            { 1, 0, 0, 1 },
            { 1, 0, 1, 0 },
            { 1, 0, 1, 1 },
            { 1, 1, 0, 0 },
            { 1, 1, 0, 1 },
            { 1, 1, 1, 0 },
            { 1, 1, 1, 1 } } };
    std::fill_n(values, num_points * 15 * num_derivatives, 0.0);
    const std::size_t reference_offsets[15] = {};
    const std::size_t physical_offsets[15] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[16][16];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 15; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[15 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[15 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void poisson2d_4_finite_element_2::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[15];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[15];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
}

void poisson2d_4_finite_element_2::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold value of a single dof.
    double dof_values = 0.0;
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 15; ++r)
    {
        evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
        values[r] = dof_values;
    }
}

void poisson2d_4_finite_element_2::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 4)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[4][16][4] =
        { { { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 0, 1, 0 },
            { 0, 1, 0, 0 },
            { 0, 1, 1, 0 },
            { 1, 0, 0, 0 },
            { 1, 0, 1, 0 },
            { 1, 1, 0, 0 },
            { 1, 1, 1, 0 },
            { 0, 0, 0, 0 },
            { 0, 0, 1, 0 },
            { 0, 1, 0, 0 },
            { 0, 1, 1, 0 },
            { 1, 0, 0, 0 },
            { 1, 0, 1, 0 },
            { 1, 1, 0, 0 },
            { 1, 1, 1, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 0, 0, 1 },
            { 0, 0, 1, 0 },
            { 0, 0, 1, 1 },
            { 0, 1, 0, 0 },
            { 0, 1, 0, 1 },
            { 0, 1, 1, 0 },
            { 0, 1, 1, 1 },
            { 1, 0, 0, 0 },
            { 1, 0, 0, 1 },
            { 1, 0, 1, 0 },
            { 1, 0, 1, 1 },
            { 1, 1, 0, 0 },
            { 1, 1, 0, 1 },
            { 1, 1, 1, 0 },
            { 1, 1, 1, 1 } } };
    // Declare transformation matrix
    double transform[16][16] =
        { { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.0, -0.041239304942116146, -0.0238095238095238, 0.02898002949762787, 0.02244783432338248, 0.012960263189329005, -0.0395942580610999, -0.03346325566315744, -0.02592052637865797, -0.014965222882254969, 0.03212472543663115, 0.02833134481385228, 0.023944356611607938, 0.018547218878481833, 0.010708241812210372 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.0, 0.04123930494211611, -0.023809523809523784, 0.02898002949762787, -0.022447834323382453, 0.012960263189329, 0.03959425806109992, -0.03346325566315744, 0.025920526378657965, -0.014965222882254981, 0.03212472543663115, -0.028331344813852296, 0.023944356611607945, -0.018547218878481826, 0.010708241812210383 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.0, 0.0, 0.047619047619047616, 0.0, 0.0, 0.038880789567986934, 0.0, 0.0, 0.0, 0.0598608915290199, 0.0, 0.0, 0.0, 0.0, 0.05354120906105193 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.12570787221094165, 0.1319657758147716, -0.025396825396825355, 0.13910414158861367, -0.07183306983482386, 0.03110463165438956, 0.06335081289775986, 0.026770604530525936, -0.06220926330877912, 0.0478887132232159, 0.0, 0.05666268962770458, -0.08380524814062787, 0.08346248495316816, -0.05354120906105191 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { -0.03142696805273556, 0.010997147984564411, 0.006349206349206314, 0.0, 0.18856180831641273, -0.16329931618554522, 0.0, 0.09369711585684086, 0.0, -0.041902624070313914, 0.0, 0.0, 0.08380524814062786, -0.13910414158861362, 0.10708241812210385 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.12570787221094176, 0.04398859193825711, 0.12698412698412703, 0.0, 0.03591653491741193, 0.1555231582719478, 0.0, 0.0, 0.10368210551463192, -0.011972178305804009, 0.0, 0.0, 0.0, 0.09273609439240907, -0.10708241812210383 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 6:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.1257078722109417, -0.1319657758147716, -0.025396825396825393, 0.13910414158861367, 0.07183306983482389, 0.03110463165438956, -0.06335081289775987, 0.026770604530525956, 0.06220926330877912, 0.04788871322321592, 0.0, -0.05666268962770459, -0.08380524814062787, -0.08346248495316817, -0.05354120906105193 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 7:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { -0.03142696805273538, -0.010997147984564368, 0.006349206349206332, 0.0, -0.18856180831641273, -0.16329931618554525, 0.0, 0.09369711585684083, 0.0, -0.041902624070313914, 0.0, 0.0, 0.0838052481406279, 0.13910414158861362, 0.10708241812210385 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 8:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.1257078722109417, -0.04398859193825721, 0.12698412698412698, 0.0, -0.03591653491741196, 0.15552315827194782, 0.0, 0.0, -0.1036821055146319, -0.011972178305804009, 0.0, 0.0, 0.0, -0.0927360943924091, -0.10708241812210383 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 9:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.12570787221094154, -0.08797718387651446, -0.10158730158730156, 0.09273609439240907, 0.10774960475223581, 0.07257747386024228, 0.07918851612219979, -0.013385302265262968, -0.051841052757315924, -0.041902624070313914, -0.12849890174652462, -0.05666268962770459, -0.01197217830580395, 0.009273609439240903, 0.010708241812210388 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 10:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { -0.03142696805273548, 0.0, -0.01269841269841278, -0.24343224778007383, 0.0, 0.054433105395181716, 0.0, 0.09369711585684085, 0.0, -0.041902624070313914, 0.1927483526197869, 0.0, -0.023944356611607952, 0.0, 0.0107082418122104 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 11:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.12570787221094165, 0.08797718387651449, -0.10158730158730152, 0.09273609439240907, -0.10774960475223581, 0.07257747386024233, -0.07918851612219986, -0.013385302265262985, 0.05184105275731595, -0.041902624070313914, -0.12849890174652456, 0.05666268962770458, -0.01197217830580399, -0.009273609439240904, 0.010708241812210374 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 12:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.2514157444218837, -0.3519087355060576, -0.20317460317460315, -0.13910414158861356, -0.10774960475223581, -0.06220926330877912, 0.19005243869327956, -0.02677060453052593, 0.12441852661755823, 0.15563831797545172, 0.0, 0.16998806888311377, 0.08380524814062781, -0.02782082831772274, -0.05354120906105193 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 13:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.25141574442188397, 0.3519087355060575, -0.20317460317460315, -0.13910414158861364, 0.10774960475223574, -0.06220926330877919, -0.19005243869327954, -0.026770604530525943, -0.12441852661755823, 0.15563831797545172, 0.0, -0.16998806888311374, 0.08380524814062784, 0.027820828317722715, -0.05354120906105189 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 14:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.2514157444218835, 0.0, 0.4063492063492063, 0.0, 0.0, -0.18662778992633736, 0.0, -0.18739423171368175, 0.0, -0.20352703119866758, 0.0, 0.0, -0.16761049628125563, 0.0, 0.10708241812210378 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.48683298050515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865467, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -1.6887507151953062e-14, -2.9933259094191693, 13.662601021279482, -1.2588555812793067e-14, 0.6110100926607921, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 4.381780460041353, 0.0, 0.0, 12.521980673998852, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.086152165333433e-14, 0.0 },
                  { 3.46410161513776, 0.0, 7.838367176906172, 0.0, 0.0, 8.400000000000006, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.102218166309243e-14, 10.954451150103328, 3.3106696863146976e-14, -8.284123166750016e-14, -3.833259389999657, -1.5498274338021567e-14, 17.748239349298842, 0.0, 0.553283335172499, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.73286382647968, -3.249440381171622e-14, 3.3466401061362974, 4.3643578047198455, -7.330507568015141e-14, -5.074680379332347, 0.0, 17.0084012854152, 3.111356537967603e-14, 1.52127765851132, 0.0, -1.061945161296667e-14, 1.0337545242332144e-14, 0.0, 0.0 },
                  { 0.0, 2.4494897427831632, 0.0, 0.0, 9.14285714285709, 0.0, 0.0, 0.0, 14.846149779161822, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769658968, 0.0, 7.668115805072262, 0.0, 0.0, 10.733126291998925, 0.0, 0.0, 0.0, 9.295160030897781, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.5819888974716196, 4.743416490252574, -0.9128709291752797, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999127, 6.123724356957939, 3.5355339059327333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758487, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6457513110645747, 5.1845925587262425, -1.496662954709566, 6.831300510639733, -1.0583005244258405, 0.3055050463303949, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998404, 2.190890230020676, 2.529822128134687, 8.082903768654784, 6.26099033699942, -1.807392228230122, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568873, -5.091168824543132, 3.9191835884530835, 0.0, 9.699484522385708, 4.199999999999997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.000000000000024, 0.0, -2.8284271247462685, 0.0, 0.0, 12.12435565298213, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.683281572999717, 5.4772255750516425, -1.8973665961010078, 7.423074889580864, -1.9166296949998267, 0.6639400022069794, 8.874119674649425, -1.0714285714285658, 0.2766416675862495, -0.09583148474999256, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.366431913239828, 2.8982753492378444, 1.673320053068146, 2.1821789023598566, 5.747048932153873, -2.537340189666169, 10.062305898749047, 8.504200642707618, -2.1957751641341794, 0.7606388292556577, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999982, 1.2247448713915825, 3.53553390593273, -7.377111135633133, 4.5714285714285445, 1.6495721976846596, 0.0, 11.499778169998956, 7.423074889580909, -2.571428571428574, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.549193338482892, 6.6407830863535855, 3.834057902536115, 0.0, -6.196773353931899, 5.366563145999477, 0.0, 0.0, 13.41640786499871, 4.647580015448895, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639997105, 0.0, 8.854377448471439, 0.0, 0.0, -3.0983866769660207, 0.0, 0.0, 0.0, 16.09968943799847, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void poisson2d_4_finite_element_2::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, num_derivatives * 15, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 4)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[16] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 15; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < num_derivatives; ++s)
            values[num_derivatives * r + s] = dof_values[s];
    }
}

double poisson2d_4_finite_element_2::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = 0.75 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
            y[1] = 0.75 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 5:
        {
            y[0] = 0.25 * coordinate_dofs[2] + 0.75 * coordinate_dofs[4];
            y[1] = 0.25 * coordinate_dofs[3] + 0.75 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 6:
        {
            y[0] = 0.75 * coordinate_dofs[0] + 0.25 * coordinate_dofs[4];
            y[1] = 0.75 * coordinate_dofs[1] + 0.25 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 7:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 8:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.75 * coordinate_dofs[4];
            y[1] = 0.25 * coordinate_dofs[1] + 0.75 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 9:
        {
            y[0] = 0.75 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2];
            y[1] = 0.75 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 10:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 11:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.75 * coordinate_dofs[2];
            y[1] = 0.25 * coordinate_dofs[1] + 0.75 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 12:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 13:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
            y[1] = 0.25 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 14:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
}

void poisson2d_4_finite_element_2::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.75 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
    y[1] = 0.75 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.25 * coordinate_dofs[2] + 0.75 * coordinate_dofs[4];
    y[1] = 0.25 * coordinate_dofs[3] + 0.75 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.75 * coordinate_dofs[0] + 0.25 * coordinate_dofs[4];
    y[1] = 0.75 * coordinate_dofs[1] + 0.25 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.25 * coordinate_dofs[0] + 0.75 * coordinate_dofs[4];
    y[1] = 0.25 * coordinate_dofs[1] + 0.75 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.75 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2];
    y[1] = 0.75 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[10] = vals[0];
    y[0] = 0.25 * coordinate_dofs[0] + 0.75 * coordinate_dofs[2];
    y[1] = 0.25 * coordinate_dofs[1] + 0.75 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[11] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[12] = vals[0];
    y[0] = 0.25 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
    y[1] = 0.25 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[13] = vals[0];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[14] = vals[0];
}

void poisson2d_4_finite_element_2::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
}

void poisson2d_4_finite_element_2::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = 0.75 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
    dof_coordinates[2 * 3 + 1] = 0.75 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
    dof_coordinates[2 * 4] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 4 + 1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 5] = 0.25 * coordinate_dofs[2] + 0.75 * coordinate_dofs[4];
    dof_coordinates[2 * 5 + 1] = 0.25 * coordinate_dofs[3] + 0.75 * coordinate_dofs[5];
    dof_coordinates[2 * 6] = 0.75 * coordinate_dofs[0] + 0.25 * coordinate_dofs[4];
    dof_coordinates[2 * 6 + 1] = 0.75 * coordinate_dofs[1] + 0.25 * coordinate_dofs[5];
    dof_coordinates[2 * 7] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 7 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 8] = 0.25 * coordinate_dofs[0] + 0.75 * coordinate_dofs[4];
    dof_coordinates[2 * 8 + 1] = 0.25 * coordinate_dofs[1] + 0.75 * coordinate_dofs[5];
    dof_coordinates[2 * 9] = 0.75 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2];
    dof_coordinates[2 * 9 + 1] = 0.75 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3];
    dof_coordinates[2 * 10] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    dof_coordinates[2 * 10 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    dof_coordinates[2 * 11] = 0.25 * coordinate_dofs[0] + 0.75 * coordinate_dofs[2];
    dof_coordinates[2 * 11 + 1] = 0.25 * coordinate_dofs[1] + 0.75 * coordinate_dofs[3];
    dof_coordinates[2 * 12] = 0.5 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
    dof_coordinates[2 * 12 + 1] = 0.5 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
    dof_coordinates[2 * 13] = 0.25 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
    dof_coordinates[2 * 13 + 1] = 0.25 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
    dof_coordinates[2 * 14] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 14 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
}

void poisson2d_4_finite_element_2::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[30] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.75, 0.25, 0.5, 0.5, 0.25, 0.75, 0.0, 0.25, 0.0, 0.5, 0.0, 0.75, 0.25, 0.0, 0.5, 0.0, 0.75, 0.0, 0.25, 0.25, 0.5, 0.25, 0.25, 0.5 };
    std::copy_n(dof_X, 30, reference_dof_coordinates);
}

std::size_t poisson2d_4_finite_element_2::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * poisson2d_4_finite_element_2::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * poisson2d_4_finite_element_2::create() const
{
    return new poisson2d_4_finite_element_2();
}


poisson2d_4_dofmap_0::poisson2d_4_dofmap_0() : ufc::dofmap()
{
    // Do nothing
}

poisson2d_4_dofmap_0::~poisson2d_4_dofmap_0()
{
    // Do nothing
}

const char * poisson2d_4_dofmap_0::signature() const
{
    return "FFC dofmap for FiniteElement('Lagrange', triangle, 1)";
}

bool poisson2d_4_dofmap_0::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t poisson2d_4_dofmap_0::topological_dimension() const
{
    return 2;
}

std::size_t poisson2d_4_dofmap_0::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return num_global_entities[0];
}

std::size_t poisson2d_4_dofmap_0::num_global_support_dofs() const
{
    return 0;
}

std::size_t poisson2d_4_dofmap_0::num_element_support_dofs() const
{
    return 3;
}

std::size_t poisson2d_4_dofmap_0::num_element_dofs() const
{
    return 3;
}

std::size_t poisson2d_4_dofmap_0::num_facet_dofs() const
{
    return 2;
}

std::size_t poisson2d_4_dofmap_0::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 1, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t poisson2d_4_dofmap_0::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 1, 2, 3 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void poisson2d_4_dofmap_0::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    dofs[0] = entity_indices[0][0];
    dofs[1] = entity_indices[0][1];
    dofs[2] = entity_indices[0][2];
}

void poisson2d_4_dofmap_0::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        break;
    }
}

void poisson2d_4_dofmap_0::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    }
}

void poisson2d_4_dofmap_0::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            break;
        }
        break;
    }
}

std::size_t poisson2d_4_dofmap_0::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * poisson2d_4_dofmap_0::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * poisson2d_4_dofmap_0::create() const
{
    return new poisson2d_4_dofmap_0();
}


poisson2d_4_dofmap_1::poisson2d_4_dofmap_1() : ufc::dofmap()
{
    // Do nothing
}

poisson2d_4_dofmap_1::~poisson2d_4_dofmap_1()
{
    // Do nothing
}

const char * poisson2d_4_dofmap_1::signature() const
{
    return "FFC dofmap for VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
}

bool poisson2d_4_dofmap_1::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t poisson2d_4_dofmap_1::topological_dimension() const
{
    return 2;
}

std::size_t poisson2d_4_dofmap_1::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 2 * num_global_entities[0];
}

std::size_t poisson2d_4_dofmap_1::num_global_support_dofs() const
{
    return 0;
}

std::size_t poisson2d_4_dofmap_1::num_element_support_dofs() const
{
    return 6;
}

std::size_t poisson2d_4_dofmap_1::num_element_dofs() const
{
    return 6;
}

std::size_t poisson2d_4_dofmap_1::num_facet_dofs() const
{
    return 4;
}

std::size_t poisson2d_4_dofmap_1::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 2, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t poisson2d_4_dofmap_1::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 2, 4, 6 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void poisson2d_4_dofmap_1::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + entity_indices[0][0];
    dofs[4] = offset + entity_indices[0][1];
    dofs[5] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
}

void poisson2d_4_dofmap_1::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 4;
        dofs[3] = 5;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 5;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 4;
        break;
    }
}

void poisson2d_4_dofmap_1::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            break;
        }
        break;
    }
}

void poisson2d_4_dofmap_1::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 5;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 5;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 4;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            break;
        }
        break;
    }
}

std::size_t poisson2d_4_dofmap_1::num_sub_dofmaps() const
{
    return 2;
}

ufc::dofmap * poisson2d_4_dofmap_1::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new poisson2d_4_dofmap_0();
    case 1:
        return new poisson2d_4_dofmap_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * poisson2d_4_dofmap_1::create() const
{
    return new poisson2d_4_dofmap_1();
}


poisson2d_4_dofmap_2::poisson2d_4_dofmap_2() : ufc::dofmap()
{
    // Do nothing
}

poisson2d_4_dofmap_2::~poisson2d_4_dofmap_2()
{
    // Do nothing
}

const char * poisson2d_4_dofmap_2::signature() const
{
    return "FFC dofmap for FiniteElement('Lagrange', triangle, 4)";
}

bool poisson2d_4_dofmap_2::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = { true, true, true };
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t poisson2d_4_dofmap_2::topological_dimension() const
{
    return 2;
}

std::size_t poisson2d_4_dofmap_2::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return num_global_entities[0] + 3 * num_global_entities[1] + 3 * num_global_entities[2];
}

std::size_t poisson2d_4_dofmap_2::num_global_support_dofs() const
{
    return 0;
}

std::size_t poisson2d_4_dofmap_2::num_element_support_dofs() const
{
    return 15;
}

std::size_t poisson2d_4_dofmap_2::num_element_dofs() const
{
    return 15;
}

std::size_t poisson2d_4_dofmap_2::num_facet_dofs() const
{
    return 5;
}

std::size_t poisson2d_4_dofmap_2::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 1, 3, 3 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t poisson2d_4_dofmap_2::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 1, 5, 15 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void poisson2d_4_dofmap_2::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + 3 * entity_indices[1][0];
    dofs[4] = offset + 3 * entity_indices[1][0] + 1;
    dofs[5] = offset + 3 * entity_indices[1][0] + 2;
    dofs[6] = offset + 3 * entity_indices[1][1];
    dofs[7] = offset + 3 * entity_indices[1][1] + 1;
    dofs[8] = offset + 3 * entity_indices[1][1] + 2;
    dofs[9] = offset + 3 * entity_indices[1][2];
    dofs[10] = offset + 3 * entity_indices[1][2] + 1;
    dofs[11] = offset + 3 * entity_indices[1][2] + 2;
    offset += 3 * num_global_entities[1];
    dofs[12] = offset + 3 * entity_indices[2][0];
    dofs[13] = offset + 3 * entity_indices[2][0] + 1;
    dofs[14] = offset + 3 * entity_indices[2][0] + 2;
    offset += 3 * num_global_entities[2];
}

void poisson2d_4_dofmap_2::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 5;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 6;
        dofs[3] = 7;
        dofs[4] = 8;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 9;
        dofs[3] = 10;
        dofs[4] = 11;
        break;
    }
}

void poisson2d_4_dofmap_2::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 3;
            dofs[1] = 4;
            dofs[2] = 5;
            break;
        case 1:
            dofs[0] = 6;
            dofs[1] = 7;
            dofs[2] = 8;
            break;
        case 2:
            dofs[0] = 9;
            dofs[1] = 10;
            dofs[2] = 11;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 12;
            dofs[1] = 13;
            dofs[2] = 14;
            break;
        }
        break;
    }
}

void poisson2d_4_dofmap_2::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 5;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 6;
            dofs[3] = 7;
            dofs[4] = 8;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 9;
            dofs[3] = 10;
            dofs[4] = 11;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            break;
        }
        break;
    }
}

std::size_t poisson2d_4_dofmap_2::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * poisson2d_4_dofmap_2::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * poisson2d_4_dofmap_2::create() const
{
    return new poisson2d_4_dofmap_2();
}


poisson2d_4_coordinate_mapping_1::poisson2d_4_coordinate_mapping_1() : ufc::coordinate_mapping()
{
    // Do nothing
}

poisson2d_4_coordinate_mapping_1::~poisson2d_4_coordinate_mapping_1()
{
    // Do nothing
}

const char * poisson2d_4_coordinate_mapping_1::signature() const
{
    return "FFC coordinate_mapping from VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
}

ufc::coordinate_mapping * poisson2d_4_coordinate_mapping_1::create() const
{
    return new poisson2d_4_coordinate_mapping_1();
}

std::size_t poisson2d_4_coordinate_mapping_1::geometric_dimension() const
{
    return 2;
}

std::size_t poisson2d_4_coordinate_mapping_1::topological_dimension() const
{
    return 2;
}

ufc::shape poisson2d_4_coordinate_mapping_1::cell_shape() const
{
    return ufc::shape::triangle;
}

ufc::finite_element * poisson2d_4_coordinate_mapping_1::create_coordinate_finite_element() const
{
    return new poisson2d_4_finite_element_1();
}

ufc::dofmap * poisson2d_4_coordinate_mapping_1::create_coordinate_dofmap() const
{
    return new poisson2d_4_dofmap_1();
}

void poisson2d_4_coordinate_mapping_1::compute_physical_coordinates(
    double * x, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs) const
{
    poisson2d_4_finite_element_0 xelement;
    double phi[3];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis values of coordinate element
        xelement.evaluate_reference_basis(phi, 1, &X[2 * ip]);
        // Compute x
        for (std::size_t i = 0; i < 2; ++i)
            for (std::size_t d = 0; d < 3; ++d)
                x[2 * ip + i] += coordinate_dofs[2 * d + i] * phi[d];
    }
}

void poisson2d_4_coordinate_mapping_1::compute_reference_coordinates(
    double * X, std::size_t num_points,
    const double * x,
    const double * coordinate_dofs, int cell_orientation) const
{
    const double phi_X0[3] = { 1.0, 0.0, 0.0 };
    const double dphi_X0[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    double J[4];
    double detJ[1];
    double K[4];
    double x0[2] = {};
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t k = 0; k < 3; ++k)
            x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 2; ++i)
    {
        for (std::size_t j = 0; j < 2; ++j)
        {
            J[2 * i + j] = 0.0;
            for (std::size_t k = 0; k < 3; ++k)
                J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t i = 0; i < 2; ++i)
                X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
}

void poisson2d_4_coordinate_mapping_1::compute_reference_geometry(
    double * X, double * J, double * detJ, double * K, std::size_t num_points,
    const double * x,
    const double * coordinate_dofs, int cell_orientation) const
{
    const double phi_X0[3] = { 1.0, 0.0, 0.0 };
    const double dphi_X0[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    double x0[2] = {};
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t k = 0; k < 3; ++k)
            x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 2; ++i)
    {
        for (std::size_t j = 0; j < 2; ++j)
        {
            J[2 * i + j] = 0.0;
            for (std::size_t k = 0; k < 3; ++k)
                J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t i = 0; i < 2; ++i)
                X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
}

void poisson2d_4_coordinate_mapping_1::compute_jacobians(
    double * J, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs) const
{
    poisson2d_4_finite_element_0 xelement;
    double dphi[6];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis derivatives of coordinate element
        xelement.evaluate_reference_basis_derivatives(dphi, 1, 1, &X[2 * ip]);
        // Compute J
        for (std::size_t i = 0; i < 2; ++i)
            for (std::size_t j = 0; j < 2; ++j)
                for (std::size_t d = 0; d < 3; ++d)
                    J[2 * 2 * ip + 2 * i + j] += coordinate_dofs[2 * d + i] * dphi[2 * d + j];
    }
}

void poisson2d_4_coordinate_mapping_1::compute_jacobian_determinants(
    double * detJ, std::size_t num_points,
    const double * J,
    int cell_orientation) const
{
    for (std::size_t ip = 0; ip < num_points; ++ip)
        detJ[ip] = J[2 * 2 * ip] * J[2 * 2 * ip + 2 + 1] - J[2 * 2 * ip + 1] * J[2 * 2 * ip + 2];
}

void poisson2d_4_coordinate_mapping_1::compute_jacobian_inverses(
    double * K, std::size_t num_points,
    const double * J, const double * detJ) const
{
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        K[2 * 2 * ip] = J[2 * 2 * ip + 2 + 1] / detJ[ip];
        K[2 * 2 * ip + 1] = -J[2 * 2 * ip + 1] / detJ[ip];
        K[2 * 2 * ip + 2] = -J[2 * 2 * ip + 2] / detJ[ip];
        K[2 * 2 * ip + 2 + 1] = J[2 * 2 * ip] / detJ[ip];
    }
}

void poisson2d_4_coordinate_mapping_1::compute_geometry(
    double * x, double * J, double * detJ, double * K, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs, int cell_orientation) const
{
    compute_physical_coordinates(x, num_points, X, coordinate_dofs);
    compute_jacobians(J, num_points, X, coordinate_dofs);
    compute_jacobian_determinants(detJ, num_points, J, cell_orientation);
    compute_jacobian_inverses(K, num_points, J, detJ);
}

void poisson2d_4_coordinate_mapping_1::compute_midpoint_geometry(
    double * x, double * J,
    const double * coordinate_dofs) const
{
    const double phi_Xm[3] = { 0.3333333333333333, 0.3333333333333333, 0.3333333333333333 };
    const double dphi_Xm[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    // Compute x
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t d = 0; d < 3; ++d)
            x[i] += coordinate_dofs[2 * d + i] * phi_Xm[d];
    // Compute J
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t d = 0; d < 3; ++d)
                J[2 * i + j] += coordinate_dofs[2 * d + i] * dphi_Xm[j][d];
}


poisson2d_4_cell_integral_0_otherwise::poisson2d_4_cell_integral_0_otherwise() : ufc::cell_integral()
{

}

poisson2d_4_cell_integral_0_otherwise::~poisson2d_4_cell_integral_0_otherwise()
{

}

const std::vector<bool> & poisson2d_4_cell_integral_0_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void poisson2d_4_cell_integral_0_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation,
                                    std::size_t local_facet) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 6
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q12[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double PI0[1][14][14] =
        { { { 0.3730158730158787, 0.05661375661375734, 0.04232804232804197, 0.04232804232804507, 0.04232804232804206, 0.1269841269841289, 0.04232804232804208, -0.04232804232804199, -0.6518518518518622, 0.4677248677248749, -0.2455026455026487, -0.08465608465608654, -0.0846560846560843, -0.08465608465608705 },
            { 0.05661375661375734, 0.373015873015876, 0.1269841269841281, 0.04232804232804309, -0.04232804232804245, 0.04232804232804439, 0.04232804232804547, 0.04232804232804251, -0.2455026455026463, 0.4677248677248688, -0.6518518518518557, -0.08465608465608666, -0.08465608465608582, -0.0846560846560889 },
            { 0.04232804232804197, 0.1269841269841281, 1.828571428571445, -0.6603174603174614, 0.3386243386243387, -0.2031746031746052, -0.1523809523809667, -0.3386243386243383, -0.1354497354497375, 0.1015873015873064, -0.1354497354497385, 0.8126984126984349, -2.438095238095274, 0.812698412698428 },
            { 0.04232804232804507, 0.04232804232804309, -0.6603174603174614, 2.450793650793677, -0.7619047619047612, -0.152380952380962, 0.3936507936508206, 0.7619047619047613, -0.06772486772487488, 0.05079365079365763, -0.06772486772487207, 0.4063492063492198, 0.406349206349203, -2.844444444444498 },
            { 0.04232804232804206, -0.04232804232804245, 0.3386243386243387, -0.7619047619047612, 2.099470899470905, -0.3386243386243367, 0.7619047619047599, -2.099470899470905, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.1269841269841289, 0.04232804232804439, -0.2031746031746052, -0.152380952380962, -0.3386243386243367, 1.82857142857145, -0.6603174603174597, 0.3386243386243375, -0.1354497354497458, 0.1015873015873189, -0.1354497354497466, -2.438095238095282, 0.8126984126984378, 0.8126984126984196 },
            { 0.04232804232804208, 0.04232804232804547, -0.1523809523809667, 0.3936507936508206, 0.7619047619047599, -0.6603174603174597, 2.45079365079368, -0.7619047619047602, -0.0677248677248691, 0.05079365079365802, -0.06772486772487543, 0.4063492063491931, 0.4063492063492327, -2.8444444444445 },
            { -0.04232804232804199, 0.04232804232804251, -0.3386243386243383, 0.7619047619047613, -2.099470899470905, 0.3386243386243375, -0.7619047619047602, 2.099470899470906, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { -0.6518518518518622, -0.2455026455026463, -0.1354497354497375, -0.06772486772487488, 0.0, -0.1354497354497458, -0.0677248677248691, 0.0, 1.828571428571457, -1.947089947089973, 1.015873015873025, 0.1354497354497461, 0.1354497354497369, 0.1354497354497436 },
            { 0.4677248677248749, 0.4677248677248688, 0.1015873015873064, 0.05079365079365763, 0.0, 0.1015873015873189, 0.05079365079365802, 0.0, -1.947089947089973, 2.958730158730194, -1.947089947089965, -0.101587301587323, -0.1015873015873023, -0.1015873015873158 },
            { -0.2455026455026487, -0.6518518518518557, -0.1354497354497385, -0.06772486772487207, 0.0, -0.1354497354497466, -0.06772486772487543, 0.0, 1.015873015873025, -1.947089947089965, 1.828571428571444, 0.1354497354497503, 0.1354497354497347, 0.1354497354497483 },
            { -0.08465608465608654, -0.08465608465608666, 0.8126984126984349, 0.4063492063492198, 0.0, -2.438095238095282, 0.4063492063491931, 0.0, 0.1354497354497461, -0.101587301587323, 0.1354497354497503, 5.688888888888968, -4.063492063492122, -0.8126984126984083 },
            { -0.0846560846560843, -0.08465608465608582, -2.438095238095274, 0.406349206349203, 0.0, 0.8126984126984378, 0.4063492063492327, 0.0, 0.1354497354497369, -0.1015873015873023, 0.1354497354497347, -4.063492063492122, 5.688888888888957, -0.8126984126984385 },
            { -0.08465608465608705, -0.0846560846560889, 0.812698412698428, -2.844444444444498, 0.0, 0.8126984126984196, -2.8444444444445, 0.0, 0.1354497354497436, -0.1015873015873158, 0.1354497354497483, -0.8126984126984083, -0.8126984126984385, 5.688888888888997 } } };
    alignas(32) static const double PI1[1][14][14] =
        { { { 0.3730158730158786, 0.05661375661375673, 0.04232804232804093, 0.04232804232804496, 0.04232804232804323, -0.6518518518518602, 0.4677248677248727, -0.2455026455026485, 0.1269841269841291, 0.04232804232804324, -0.04232804232804243, -0.08465608465608859, -0.08465608465608723, -0.08465608465608269 },
            { 0.05661375661375687, -0.05661375661375667, 0.7788359788359853, -0.4253968253968299, 0.2031746031746049, 0.0, 0.0, 0.0, -0.2031746031746037, 0.4253968253968263, -0.7788359788359832, 0.0, 0.0, 0.0 },
            { 0.04232804232804196, 0.2031746031746026, 1.049735449735457, 0.8211640211640289, -0.4402116402116402, -0.1015873015873025, -0.04232804232804421, -0.1015873015872901, -0.2370370370370473, 0.4656084656084767, -1.049735449735453, 0.3386243386243485, -1.286772486772505, 0.3386243386243224 },
            { 0.04232804232804514, -0.4253968253968247, -0.2962962962962991, 0.9714285714285891, 0.8211640211640303, -0.110052910052919, 0.196825396825417, 0.2962962962962853, -0.1100529100529176, 0.1968253968253999, 0.2962962962962961, 0.4571428571428793, -1.168253968253981, -1.168253968254001 },
            { 0.04232804232804191, 0.7788359788359787, 0.1015873015873017, -0.2962962962963004, 1.049735449735455, -0.2370370370370383, 0.4656084656084649, -1.049735449735444, -0.1015873015873037, -0.04232804232804009, -0.1015873015872962, 0.3386243386243469, 0.3386243386243309, -1.286772486772499 },
            { 0.1269841269841291, -0.2031746031746027, -0.1015873015873034, -0.1100529100529117, -0.2370370370370423, 0.7788359788359932, -1.481481481481502, 0.7788359788359771, 0.9142857142857163, -0.3640211640211647, 0.1015873015873013, -1.151322751322764, 0.4740740740740753, 0.4740740740740975 },
            { 0.04232804232804319, 0.4253968253968249, -0.04232804232804394, 0.1968253968254018, 0.4656084656084767, -0.3640211640211646, 1.479365079365093, -1.583068783068797, -0.3640211640211648, -0.1460317460317452, 0.04232804232804185, 1.574603174603181, -0.05079365079365102, -1.676190476190496 },
            { -0.04232804232804183, -0.7788359788359789, -0.1015873015873015, 0.2962962962963006, -1.049735449735456, 0.2370370370370386, -0.4656084656084652, 1.049735449735444, 0.1015873015873041, 0.04232804232804013, 0.101587301587296, -0.338624338624347, -0.3386243386243311, 1.2867724867725 },
            { -0.6518518518518619, 0.0, -0.2370370370370343, -0.1100529100529192, -0.101587301587307, 0.9142857142857223, -0.3640211640211605, 0.1015873015872987, 0.7788359788359871, -0.3640211640211626, 0.2370370370370345, -1.151322751322772, 0.4740740740740811, 0.4740740740740922 },
            { 0.4677248677248746, 0.0, 0.4656084656084609, 0.1968253968254176, -0.04232804232804673, -0.3640211640211614, -0.1460317460317577, 0.04232804232804396, -1.481481481481492, 1.47936507936509, -0.4656084656084618, 1.574603174603197, -1.676190476190507, -0.05079365079365853 },
            { -0.2455026455026482, 0.0, -1.049735449735453, 0.2962962962962865, -0.1015873015872942, 0.101587301587297, 0.04232804232804621, 0.1015873015873053, 0.7788359788359797, -1.583068783068798, 1.049735449735453, -0.3386243386243347, 1.286772486772512, -0.338624338624347 },
            { -0.08465608465608496, 0.0, 0.3386243386243458, 0.4571428571428761, 0.3386243386243588, -1.151322751322783, 1.574603174603208, -0.3386243386243388, -1.151322751322759, 1.574603174603183, -0.3386243386243546, 2.84444444444446, -2.031746031746041, -2.031746031746068 },
            { -0.08465608465608604, 0.0, -1.286772486772499, -1.168253968253993, 0.338624338624323, 0.4740740740740929, -0.05079365079366305, -0.3386243386243475, 0.4740740740740909, -1.676190476190495, 1.286772486772506, -2.031746031746045, 2.844444444444469, 1.219047619047649 },
            { -0.08465608465608825, 0.0, 0.3386243386243425, -1.168253968253991, -1.286772486772508, 0.4740740740740821, -1.676190476190508, 1.286772486772511, 0.4740740740740814, -0.05079365079365464, -0.3386243386243376, -2.031746031746056, 1.219047619047632, 2.844444444444496 } } };
    alignas(32) static const double PI2[1][14][14] =
        { { { 0.3730158730158784, 0.05661375661375673, 0.0423280423280399, 0.04232804232804584, 0.04232804232804287, -0.65185185185186, 0.4677248677248726, -0.2455026455026486, 0.126984126984129, 0.04232804232804355, -0.04232804232804139, -0.08465608465608621, -0.0846560846560884, -0.08465608465608471 },
            { 0.05661375661375673, 0.3730158730158734, -0.04232804232804335, 0.0423280423280436, 0.1269841269841252, -0.245502645502647, 0.4677248677248702, -0.6518518518518527, 0.04232804232804396, 0.04232804232804676, 0.04232804232804455, -0.08465608465608966, -0.08465608465609288, -0.08465608465607931 },
            { 0.0423280423280399, -0.04232804232804335, 2.099470899470917, -0.761904761904777, 0.338624338624344, 0.0, 0.0, 0.0, -0.3386243386243459, 0.7619047619047582, -2.09947089947091, 0.0, 0.0, 0.0 },
            { 0.04232804232804584, 0.0423280423280436, -0.761904761904777, 2.45079365079369, -0.6603174603174686, -0.06772486772487568, 0.05079365079366181, -0.06772486772487046, -0.1523809523809597, 0.3936507936508203, 0.7619047619047733, 0.4063492063492187, -2.844444444444497, 0.4063492063491983 },
            { 0.04232804232804287, 0.1269841269841252, 0.338624338624344, -0.6603174603174686, 1.828571428571445, -0.1354497354497397, 0.1015873015873065, -0.1354497354497308, -0.2031746031746114, -0.1523809523809634, -0.3386243386243398, 0.8126984126984436, 0.8126984126984256, -2.438095238095282 },
            { -0.65185185185186, -0.245502645502647, 0.0, -0.06772486772487568, -0.1354497354497397, 1.828571428571454, -1.947089947089971, 1.015873015873024, -0.1354497354497405, -0.06772486772487163, 0.0, 0.1354497354497373, 0.1354497354497451, 0.1354497354497434 },
            { 0.4677248677248726, 0.4677248677248702, 0.0, 0.05079365079366181, 0.1015873015873065, -1.947089947089971, 2.958730158730194, -1.947089947089964, 0.1015873015873115, 0.05079365079365827, 0.0, -0.1015873015873127, -0.1015873015873168, -0.1015873015873077 },
            { -0.2455026455026486, -0.6518518518518527, 0.0, -0.06772486772487046, -0.1354497354497308, 1.015873015873024, -1.947089947089964, 1.828571428571441, -0.135449735449749, -0.06772486772487761, 0.0, 0.1354497354497545, 0.1354497354497486, 0.1354497354497262 },
            { 0.126984126984129, 0.04232804232804396, -0.3386243386243459, -0.1523809523809597, -0.2031746031746114, -0.1354497354497405, 0.1015873015873115, -0.135449735449749, 1.828571428571449, -0.660317460317456, 0.3386243386243418, -2.438095238095281, 0.8126984126984166, 0.8126984126984504 },
            { 0.04232804232804355, 0.04232804232804676, 0.7619047619047582, 0.3936507936508203, -0.1523809523809634, -0.06772486772487163, 0.05079365079365827, -0.06772486772487761, -0.660317460317456, 2.450793650793683, -0.7619047619047649, 0.4063492063491868, -2.844444444444495, 0.4063492063492277 },
            { -0.04232804232804139, 0.04232804232804455, -2.09947089947091, 0.7619047619047733, -0.3386243386243398, 0.0, 0.0, 0.0, 0.3386243386243418, -0.7619047619047649, 2.099470899470903, 0.0, 0.0, 0.0 },
            { -0.08465608465608621, -0.08465608465608966, 0.0, 0.4063492063492187, 0.8126984126984436, 0.1354497354497373, -0.1015873015873127, 0.1354497354497545, -2.438095238095281, 0.4063492063491868, 0.0, 5.688888888888977, -0.8126984126983924, -4.063492063492145 },
            { -0.0846560846560884, -0.08465608465609288, 0.0, -2.844444444444497, 0.8126984126984256, 0.1354497354497451, -0.1015873015873168, 0.1354497354497486, 0.8126984126984166, -2.844444444444495, 0.0, -0.8126984126983924, 5.68888888888897, -0.8126984126984335 },
            { -0.08465608465608471, -0.08465608465607931, 0.0, 0.4063492063491983, -2.438095238095282, 0.1354497354497434, -0.1015873015873077, 0.1354497354497262, 0.8126984126984504, 0.4063492063492277, 0.0, -4.063492063492145, -0.8126984126984335, 5.68888888888898 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q12[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q12[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q12[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q12[0][0][1];
    alignas(32) double sp[20];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = -1 * J_c1 / sp[2];
    sp[5] = sp[3] * sp[3];
    sp[6] = sp[3] * sp[4];
    sp[7] = sp[4] * sp[4];
    sp[8] = J_c3 / sp[2];
    sp[9] = -1 * J_c2 / sp[2];
    sp[10] = sp[9] * sp[9];
    sp[11] = sp[8] * sp[9];
    sp[12] = sp[8] * sp[8];
    sp[13] = sp[5] + sp[10];
    sp[14] = sp[6] + sp[11];
    sp[15] = sp[12] + sp[7];
    sp[16] = std::abs(sp[2]);
    sp[17] = sp[13] * sp[16];
    sp[18] = sp[14] * sp[16];
    sp[19] = sp[15] * sp[16];
    A[0] = sp[19] * PI0[0][0][0] + sp[18] * PI1[0][0][0] + sp[18] * PI1[0][0][0] + sp[17] * PI2[0][0][0];
    A[1] = sp[19] * PI0[0][0][1] + sp[18] * PI1[0][1][0];
    A[2] = sp[18] * PI1[0][0][1] + sp[17] * PI2[0][0][1];
    A[3] = sp[19] * PI0[0][0][2] + sp[18] * PI1[0][0][2] + sp[18] * PI1[0][2][0] + sp[17] * PI2[0][0][2];
    A[4] = sp[19] * PI0[0][0][3] + sp[18] * PI1[0][0][3] + sp[18] * PI1[0][3][0] + sp[17] * PI2[0][0][3];
    A[5] = sp[19] * PI0[0][0][4] + sp[18] * PI1[0][0][4] + sp[18] * PI1[0][4][0] + sp[17] * PI2[0][0][4];
    A[6] = sp[19] * PI0[0][0][5] + sp[18] * PI1[0][0][5] + sp[18] * PI1[0][5][0] + sp[17] * PI2[0][0][5];
    A[7] = sp[19] * PI0[0][0][6] + sp[18] * PI1[0][0][6] + sp[18] * PI1[0][6][0] + sp[17] * PI2[0][0][6];
    A[8] = sp[19] * PI0[0][0][7] + sp[18] * PI1[0][0][7] + sp[18] * PI1[0][7][0] + sp[17] * PI2[0][0][7];
    A[9] = sp[19] * PI0[0][0][8] + sp[18] * PI1[0][0][8] + sp[18] * PI1[0][8][0] + sp[17] * PI2[0][0][8];
    A[10] = sp[19] * PI0[0][0][9] + sp[18] * PI1[0][0][9] + sp[18] * PI1[0][9][0] + sp[17] * PI2[0][0][9];
    A[11] = sp[19] * PI0[0][0][10] + sp[18] * PI1[0][0][10] + sp[18] * PI1[0][10][0] + sp[17] * PI2[0][0][10];
    A[12] = sp[19] * PI0[0][0][11] + sp[18] * PI1[0][0][11] + sp[18] * PI1[0][11][0] + sp[17] * PI2[0][0][11];
    A[13] = sp[19] * PI0[0][0][12] + sp[18] * PI1[0][0][12] + sp[18] * PI1[0][12][0] + sp[17] * PI2[0][0][12];
    A[14] = sp[19] * PI0[0][0][13] + sp[18] * PI1[0][0][13] + sp[18] * PI1[0][13][0] + sp[17] * PI2[0][0][13];
    A[15] = sp[19] * PI0[0][1][0] + sp[18] * PI1[0][1][0];
    A[16] = sp[19] * PI0[0][1][1];
    A[17] = sp[18] * PI1[0][1][1];
    A[18] = sp[19] * PI0[0][1][2] + sp[18] * PI1[0][1][2];
    A[19] = sp[19] * PI0[0][1][3] + sp[18] * PI1[0][1][3];
    A[20] = sp[19] * PI0[0][1][4] + sp[18] * PI1[0][1][4];
    A[21] = sp[19] * PI0[0][1][5] + sp[18] * PI1[0][1][5];
    A[22] = sp[19] * PI0[0][1][6] + sp[18] * PI1[0][1][6];
    A[23] = sp[19] * PI0[0][1][7] + sp[18] * PI1[0][1][7];
    A[24] = sp[19] * PI0[0][1][8] + sp[18] * PI1[0][1][8];
    A[25] = sp[19] * PI0[0][1][9] + sp[18] * PI1[0][1][9];
    A[26] = sp[19] * PI0[0][1][10] + sp[18] * PI1[0][1][10];
    A[27] = sp[19] * PI0[0][1][11] + sp[18] * PI1[0][1][11];
    A[28] = sp[19] * PI0[0][1][12] + sp[18] * PI1[0][1][12];
    A[29] = sp[19] * PI0[0][1][13] + sp[18] * PI1[0][1][13];
    A[30] = sp[18] * PI1[0][0][1] + sp[17] * PI2[0][1][0];
    A[31] = sp[18] * PI1[0][1][1];
    A[32] = sp[17] * PI2[0][1][1];
    A[33] = sp[18] * PI1[0][2][1] + sp[17] * PI2[0][1][2];
    A[34] = sp[18] * PI1[0][3][1] + sp[17] * PI2[0][1][3];
    A[35] = sp[18] * PI1[0][4][1] + sp[17] * PI2[0][1][4];
    A[36] = sp[18] * PI1[0][5][1] + sp[17] * PI2[0][1][5];
    A[37] = sp[18] * PI1[0][6][1] + sp[17] * PI2[0][1][6];
    A[38] = sp[18] * PI1[0][7][1] + sp[17] * PI2[0][1][7];
    A[39] = sp[18] * PI1[0][8][1] + sp[17] * PI2[0][1][8];
    A[40] = sp[18] * PI1[0][9][1] + sp[17] * PI2[0][1][9];
    A[41] = sp[18] * PI1[0][10][1] + sp[17] * PI2[0][1][10];
    A[42] = sp[18] * PI1[0][11][1] + sp[17] * PI2[0][1][11];
    A[43] = sp[18] * PI1[0][12][1] + sp[17] * PI2[0][1][12];
    A[44] = sp[18] * PI1[0][13][1] + sp[17] * PI2[0][1][13];
    A[45] = sp[19] * PI0[0][2][0] + sp[18] * PI1[0][2][0] + sp[18] * PI1[0][0][2] + sp[17] * PI2[0][2][0];
    A[46] = sp[19] * PI0[0][2][1] + sp[18] * PI1[0][1][2];
    A[47] = sp[18] * PI1[0][2][1] + sp[17] * PI2[0][2][1];
    A[48] = sp[19] * PI0[0][2][2] + sp[18] * PI1[0][2][2] + sp[18] * PI1[0][2][2] + sp[17] * PI2[0][2][2];
    A[49] = sp[19] * PI0[0][2][3] + sp[18] * PI1[0][2][3] + sp[18] * PI1[0][3][2] + sp[17] * PI2[0][2][3];
    A[50] = sp[19] * PI0[0][2][4] + sp[18] * PI1[0][2][4] + sp[18] * PI1[0][4][2] + sp[17] * PI2[0][2][4];
    A[51] = sp[19] * PI0[0][2][5] + sp[18] * PI1[0][2][5] + sp[18] * PI1[0][5][2] + sp[17] * PI2[0][2][5];
    A[52] = sp[19] * PI0[0][2][6] + sp[18] * PI1[0][2][6] + sp[18] * PI1[0][6][2] + sp[17] * PI2[0][2][6];
    A[53] = sp[19] * PI0[0][2][7] + sp[18] * PI1[0][2][7] + sp[18] * PI1[0][7][2] + sp[17] * PI2[0][2][7];
    A[54] = sp[19] * PI0[0][2][8] + sp[18] * PI1[0][2][8] + sp[18] * PI1[0][8][2] + sp[17] * PI2[0][2][8];
    A[55] = sp[19] * PI0[0][2][9] + sp[18] * PI1[0][2][9] + sp[18] * PI1[0][9][2] + sp[17] * PI2[0][2][9];
    A[56] = sp[19] * PI0[0][2][10] + sp[18] * PI1[0][2][10] + sp[18] * PI1[0][10][2] + sp[17] * PI2[0][2][10];
    A[57] = sp[19] * PI0[0][2][11] + sp[18] * PI1[0][2][11] + sp[18] * PI1[0][11][2] + sp[17] * PI2[0][2][11];
    A[58] = sp[19] * PI0[0][2][12] + sp[18] * PI1[0][2][12] + sp[18] * PI1[0][12][2] + sp[17] * PI2[0][2][12];
    A[59] = sp[19] * PI0[0][2][13] + sp[18] * PI1[0][2][13] + sp[18] * PI1[0][13][2] + sp[17] * PI2[0][2][13];
    A[60] = sp[19] * PI0[0][3][0] + sp[18] * PI1[0][3][0] + sp[18] * PI1[0][0][3] + sp[17] * PI2[0][3][0];
    A[61] = sp[19] * PI0[0][3][1] + sp[18] * PI1[0][1][3];
    A[62] = sp[18] * PI1[0][3][1] + sp[17] * PI2[0][3][1];
    A[63] = sp[19] * PI0[0][3][2] + sp[18] * PI1[0][3][2] + sp[18] * PI1[0][2][3] + sp[17] * PI2[0][3][2];
    A[64] = sp[19] * PI0[0][3][3] + sp[18] * PI1[0][3][3] + sp[18] * PI1[0][3][3] + sp[17] * PI2[0][3][3];
    A[65] = sp[19] * PI0[0][3][4] + sp[18] * PI1[0][3][4] + sp[18] * PI1[0][4][3] + sp[17] * PI2[0][3][4];
    A[66] = sp[19] * PI0[0][3][5] + sp[18] * PI1[0][3][5] + sp[18] * PI1[0][5][3] + sp[17] * PI2[0][3][5];
    A[67] = sp[19] * PI0[0][3][6] + sp[18] * PI1[0][3][6] + sp[18] * PI1[0][6][3] + sp[17] * PI2[0][3][6];
    A[68] = sp[19] * PI0[0][3][7] + sp[18] * PI1[0][3][7] + sp[18] * PI1[0][7][3] + sp[17] * PI2[0][3][7];
    A[69] = sp[19] * PI0[0][3][8] + sp[18] * PI1[0][3][8] + sp[18] * PI1[0][8][3] + sp[17] * PI2[0][3][8];
    A[70] = sp[19] * PI0[0][3][9] + sp[18] * PI1[0][3][9] + sp[18] * PI1[0][9][3] + sp[17] * PI2[0][3][9];
    A[71] = sp[19] * PI0[0][3][10] + sp[18] * PI1[0][3][10] + sp[18] * PI1[0][10][3] + sp[17] * PI2[0][3][10];
    A[72] = sp[19] * PI0[0][3][11] + sp[18] * PI1[0][3][11] + sp[18] * PI1[0][11][3] + sp[17] * PI2[0][3][11];
    A[73] = sp[19] * PI0[0][3][12] + sp[18] * PI1[0][3][12] + sp[18] * PI1[0][12][3] + sp[17] * PI2[0][3][12];
    A[74] = sp[19] * PI0[0][3][13] + sp[18] * PI1[0][3][13] + sp[18] * PI1[0][13][3] + sp[17] * PI2[0][3][13];
    A[75] = sp[19] * PI0[0][4][0] + sp[18] * PI1[0][4][0] + sp[18] * PI1[0][0][4] + sp[17] * PI2[0][4][0];
    A[76] = sp[19] * PI0[0][4][1] + sp[18] * PI1[0][1][4];
    A[77] = sp[18] * PI1[0][4][1] + sp[17] * PI2[0][4][1];
    A[78] = sp[19] * PI0[0][4][2] + sp[18] * PI1[0][4][2] + sp[18] * PI1[0][2][4] + sp[17] * PI2[0][4][2];
    A[79] = sp[19] * PI0[0][4][3] + sp[18] * PI1[0][4][3] + sp[18] * PI1[0][3][4] + sp[17] * PI2[0][4][3];
    A[80] = sp[19] * PI0[0][4][4] + sp[18] * PI1[0][4][4] + sp[18] * PI1[0][4][4] + sp[17] * PI2[0][4][4];
    A[81] = sp[19] * PI0[0][4][5] + sp[18] * PI1[0][4][5] + sp[18] * PI1[0][5][4] + sp[17] * PI2[0][4][5];
    A[82] = sp[19] * PI0[0][4][6] + sp[18] * PI1[0][4][6] + sp[18] * PI1[0][6][4] + sp[17] * PI2[0][4][6];
    A[83] = sp[19] * PI0[0][4][7] + sp[18] * PI1[0][4][7] + sp[18] * PI1[0][7][4] + sp[17] * PI2[0][4][7];
    A[84] = sp[19] * PI0[0][4][8] + sp[18] * PI1[0][4][8] + sp[18] * PI1[0][8][4] + sp[17] * PI2[0][4][8];
    A[85] = sp[19] * PI0[0][4][9] + sp[18] * PI1[0][4][9] + sp[18] * PI1[0][9][4] + sp[17] * PI2[0][4][9];
    A[86] = sp[19] * PI0[0][4][10] + sp[18] * PI1[0][4][10] + sp[18] * PI1[0][10][4] + sp[17] * PI2[0][4][10];
    A[87] = sp[19] * PI0[0][4][11] + sp[18] * PI1[0][4][11] + sp[18] * PI1[0][11][4] + sp[17] * PI2[0][4][11];
    A[88] = sp[19] * PI0[0][4][12] + sp[18] * PI1[0][4][12] + sp[18] * PI1[0][12][4] + sp[17] * PI2[0][4][12];
    A[89] = sp[19] * PI0[0][4][13] + sp[18] * PI1[0][4][13] + sp[18] * PI1[0][13][4] + sp[17] * PI2[0][4][13];
    A[90] = sp[19] * PI0[0][5][0] + sp[18] * PI1[0][5][0] + sp[18] * PI1[0][0][5] + sp[17] * PI2[0][5][0];
    A[91] = sp[19] * PI0[0][5][1] + sp[18] * PI1[0][1][5];
    A[92] = sp[18] * PI1[0][5][1] + sp[17] * PI2[0][5][1];
    A[93] = sp[19] * PI0[0][5][2] + sp[18] * PI1[0][5][2] + sp[18] * PI1[0][2][5] + sp[17] * PI2[0][5][2];
    A[94] = sp[19] * PI0[0][5][3] + sp[18] * PI1[0][5][3] + sp[18] * PI1[0][3][5] + sp[17] * PI2[0][5][3];
    A[95] = sp[19] * PI0[0][5][4] + sp[18] * PI1[0][5][4] + sp[18] * PI1[0][4][5] + sp[17] * PI2[0][5][4];
    A[96] = sp[19] * PI0[0][5][5] + sp[18] * PI1[0][5][5] + sp[18] * PI1[0][5][5] + sp[17] * PI2[0][5][5];
    A[97] = sp[19] * PI0[0][5][6] + sp[18] * PI1[0][5][6] + sp[18] * PI1[0][6][5] + sp[17] * PI2[0][5][6];
    A[98] = sp[19] * PI0[0][5][7] + sp[18] * PI1[0][5][7] + sp[18] * PI1[0][7][5] + sp[17] * PI2[0][5][7];
    A[99] = sp[19] * PI0[0][5][8] + sp[18] * PI1[0][5][8] + sp[18] * PI1[0][8][5] + sp[17] * PI2[0][5][8];
    A[100] = sp[19] * PI0[0][5][9] + sp[18] * PI1[0][5][9] + sp[18] * PI1[0][9][5] + sp[17] * PI2[0][5][9];
    A[101] = sp[19] * PI0[0][5][10] + sp[18] * PI1[0][5][10] + sp[18] * PI1[0][10][5] + sp[17] * PI2[0][5][10];
    A[102] = sp[19] * PI0[0][5][11] + sp[18] * PI1[0][5][11] + sp[18] * PI1[0][11][5] + sp[17] * PI2[0][5][11];
    A[103] = sp[19] * PI0[0][5][12] + sp[18] * PI1[0][5][12] + sp[18] * PI1[0][12][5] + sp[17] * PI2[0][5][12];
    A[104] = sp[19] * PI0[0][5][13] + sp[18] * PI1[0][5][13] + sp[18] * PI1[0][13][5] + sp[17] * PI2[0][5][13];
    A[105] = sp[19] * PI0[0][6][0] + sp[18] * PI1[0][6][0] + sp[18] * PI1[0][0][6] + sp[17] * PI2[0][6][0];
    A[106] = sp[19] * PI0[0][6][1] + sp[18] * PI1[0][1][6];
    A[107] = sp[18] * PI1[0][6][1] + sp[17] * PI2[0][6][1];
    A[108] = sp[19] * PI0[0][6][2] + sp[18] * PI1[0][6][2] + sp[18] * PI1[0][2][6] + sp[17] * PI2[0][6][2];
    A[109] = sp[19] * PI0[0][6][3] + sp[18] * PI1[0][6][3] + sp[18] * PI1[0][3][6] + sp[17] * PI2[0][6][3];
    A[110] = sp[19] * PI0[0][6][4] + sp[18] * PI1[0][6][4] + sp[18] * PI1[0][4][6] + sp[17] * PI2[0][6][4];
    A[111] = sp[19] * PI0[0][6][5] + sp[18] * PI1[0][6][5] + sp[18] * PI1[0][5][6] + sp[17] * PI2[0][6][5];
    A[112] = sp[19] * PI0[0][6][6] + sp[18] * PI1[0][6][6] + sp[18] * PI1[0][6][6] + sp[17] * PI2[0][6][6];
    A[113] = sp[19] * PI0[0][6][7] + sp[18] * PI1[0][6][7] + sp[18] * PI1[0][7][6] + sp[17] * PI2[0][6][7];
    A[114] = sp[19] * PI0[0][6][8] + sp[18] * PI1[0][6][8] + sp[18] * PI1[0][8][6] + sp[17] * PI2[0][6][8];
    A[115] = sp[19] * PI0[0][6][9] + sp[18] * PI1[0][6][9] + sp[18] * PI1[0][9][6] + sp[17] * PI2[0][6][9];
    A[116] = sp[19] * PI0[0][6][10] + sp[18] * PI1[0][6][10] + sp[18] * PI1[0][10][6] + sp[17] * PI2[0][6][10];
    A[117] = sp[19] * PI0[0][6][11] + sp[18] * PI1[0][6][11] + sp[18] * PI1[0][11][6] + sp[17] * PI2[0][6][11];
    A[118] = sp[19] * PI0[0][6][12] + sp[18] * PI1[0][6][12] + sp[18] * PI1[0][12][6] + sp[17] * PI2[0][6][12];
    A[119] = sp[19] * PI0[0][6][13] + sp[18] * PI1[0][6][13] + sp[18] * PI1[0][13][6] + sp[17] * PI2[0][6][13];
    A[120] = sp[19] * PI0[0][7][0] + sp[18] * PI1[0][7][0] + sp[18] * PI1[0][0][7] + sp[17] * PI2[0][7][0];
    A[121] = sp[19] * PI0[0][7][1] + sp[18] * PI1[0][1][7];
    A[122] = sp[18] * PI1[0][7][1] + sp[17] * PI2[0][7][1];
    A[123] = sp[19] * PI0[0][7][2] + sp[18] * PI1[0][7][2] + sp[18] * PI1[0][2][7] + sp[17] * PI2[0][7][2];
    A[124] = sp[19] * PI0[0][7][3] + sp[18] * PI1[0][7][3] + sp[18] * PI1[0][3][7] + sp[17] * PI2[0][7][3];
    A[125] = sp[19] * PI0[0][7][4] + sp[18] * PI1[0][7][4] + sp[18] * PI1[0][4][7] + sp[17] * PI2[0][7][4];
    A[126] = sp[19] * PI0[0][7][5] + sp[18] * PI1[0][7][5] + sp[18] * PI1[0][5][7] + sp[17] * PI2[0][7][5];
    A[127] = sp[19] * PI0[0][7][6] + sp[18] * PI1[0][7][6] + sp[18] * PI1[0][6][7] + sp[17] * PI2[0][7][6];
    A[128] = sp[19] * PI0[0][7][7] + sp[18] * PI1[0][7][7] + sp[18] * PI1[0][7][7] + sp[17] * PI2[0][7][7];
    A[129] = sp[19] * PI0[0][7][8] + sp[18] * PI1[0][7][8] + sp[18] * PI1[0][8][7] + sp[17] * PI2[0][7][8];
    A[130] = sp[19] * PI0[0][7][9] + sp[18] * PI1[0][7][9] + sp[18] * PI1[0][9][7] + sp[17] * PI2[0][7][9];
    A[131] = sp[19] * PI0[0][7][10] + sp[18] * PI1[0][7][10] + sp[18] * PI1[0][10][7] + sp[17] * PI2[0][7][10];
    A[132] = sp[19] * PI0[0][7][11] + sp[18] * PI1[0][7][11] + sp[18] * PI1[0][11][7] + sp[17] * PI2[0][7][11];
    A[133] = sp[19] * PI0[0][7][12] + sp[18] * PI1[0][7][12] + sp[18] * PI1[0][12][7] + sp[17] * PI2[0][7][12];
    A[134] = sp[19] * PI0[0][7][13] + sp[18] * PI1[0][7][13] + sp[18] * PI1[0][13][7] + sp[17] * PI2[0][7][13];
    A[135] = sp[19] * PI0[0][8][0] + sp[18] * PI1[0][8][0] + sp[18] * PI1[0][0][8] + sp[17] * PI2[0][8][0];
    A[136] = sp[19] * PI0[0][8][1] + sp[18] * PI1[0][1][8];
    A[137] = sp[18] * PI1[0][8][1] + sp[17] * PI2[0][8][1];
    A[138] = sp[19] * PI0[0][8][2] + sp[18] * PI1[0][8][2] + sp[18] * PI1[0][2][8] + sp[17] * PI2[0][8][2];
    A[139] = sp[19] * PI0[0][8][3] + sp[18] * PI1[0][8][3] + sp[18] * PI1[0][3][8] + sp[17] * PI2[0][8][3];
    A[140] = sp[19] * PI0[0][8][4] + sp[18] * PI1[0][8][4] + sp[18] * PI1[0][4][8] + sp[17] * PI2[0][8][4];
    A[141] = sp[19] * PI0[0][8][5] + sp[18] * PI1[0][8][5] + sp[18] * PI1[0][5][8] + sp[17] * PI2[0][8][5];
    A[142] = sp[19] * PI0[0][8][6] + sp[18] * PI1[0][8][6] + sp[18] * PI1[0][6][8] + sp[17] * PI2[0][8][6];
    A[143] = sp[19] * PI0[0][8][7] + sp[18] * PI1[0][8][7] + sp[18] * PI1[0][7][8] + sp[17] * PI2[0][8][7];
    A[144] = sp[19] * PI0[0][8][8] + sp[18] * PI1[0][8][8] + sp[18] * PI1[0][8][8] + sp[17] * PI2[0][8][8];
    A[145] = sp[19] * PI0[0][8][9] + sp[18] * PI1[0][8][9] + sp[18] * PI1[0][9][8] + sp[17] * PI2[0][8][9];
    A[146] = sp[19] * PI0[0][8][10] + sp[18] * PI1[0][8][10] + sp[18] * PI1[0][10][8] + sp[17] * PI2[0][8][10];
    A[147] = sp[19] * PI0[0][8][11] + sp[18] * PI1[0][8][11] + sp[18] * PI1[0][11][8] + sp[17] * PI2[0][8][11];
    A[148] = sp[19] * PI0[0][8][12] + sp[18] * PI1[0][8][12] + sp[18] * PI1[0][12][8] + sp[17] * PI2[0][8][12];
    A[149] = sp[19] * PI0[0][8][13] + sp[18] * PI1[0][8][13] + sp[18] * PI1[0][13][8] + sp[17] * PI2[0][8][13];
    A[150] = sp[19] * PI0[0][9][0] + sp[18] * PI1[0][9][0] + sp[18] * PI1[0][0][9] + sp[17] * PI2[0][9][0];
    A[151] = sp[19] * PI0[0][9][1] + sp[18] * PI1[0][1][9];
    A[152] = sp[18] * PI1[0][9][1] + sp[17] * PI2[0][9][1];
    A[153] = sp[19] * PI0[0][9][2] + sp[18] * PI1[0][9][2] + sp[18] * PI1[0][2][9] + sp[17] * PI2[0][9][2];
    A[154] = sp[19] * PI0[0][9][3] + sp[18] * PI1[0][9][3] + sp[18] * PI1[0][3][9] + sp[17] * PI2[0][9][3];
    A[155] = sp[19] * PI0[0][9][4] + sp[18] * PI1[0][9][4] + sp[18] * PI1[0][4][9] + sp[17] * PI2[0][9][4];
    A[156] = sp[19] * PI0[0][9][5] + sp[18] * PI1[0][9][5] + sp[18] * PI1[0][5][9] + sp[17] * PI2[0][9][5];
    A[157] = sp[19] * PI0[0][9][6] + sp[18] * PI1[0][9][6] + sp[18] * PI1[0][6][9] + sp[17] * PI2[0][9][6];
    A[158] = sp[19] * PI0[0][9][7] + sp[18] * PI1[0][9][7] + sp[18] * PI1[0][7][9] + sp[17] * PI2[0][9][7];
    A[159] = sp[19] * PI0[0][9][8] + sp[18] * PI1[0][9][8] + sp[18] * PI1[0][8][9] + sp[17] * PI2[0][9][8];
    A[160] = sp[19] * PI0[0][9][9] + sp[18] * PI1[0][9][9] + sp[18] * PI1[0][9][9] + sp[17] * PI2[0][9][9];
    A[161] = sp[19] * PI0[0][9][10] + sp[18] * PI1[0][9][10] + sp[18] * PI1[0][10][9] + sp[17] * PI2[0][9][10];
    A[162] = sp[19] * PI0[0][9][11] + sp[18] * PI1[0][9][11] + sp[18] * PI1[0][11][9] + sp[17] * PI2[0][9][11];
    A[163] = sp[19] * PI0[0][9][12] + sp[18] * PI1[0][9][12] + sp[18] * PI1[0][12][9] + sp[17] * PI2[0][9][12];
    A[164] = sp[19] * PI0[0][9][13] + sp[18] * PI1[0][9][13] + sp[18] * PI1[0][13][9] + sp[17] * PI2[0][9][13];
    A[165] = sp[19] * PI0[0][10][0] + sp[18] * PI1[0][10][0] + sp[18] * PI1[0][0][10] + sp[17] * PI2[0][10][0];
    A[166] = sp[19] * PI0[0][10][1] + sp[18] * PI1[0][1][10];
    A[167] = sp[18] * PI1[0][10][1] + sp[17] * PI2[0][10][1];
    A[168] = sp[19] * PI0[0][10][2] + sp[18] * PI1[0][10][2] + sp[18] * PI1[0][2][10] + sp[17] * PI2[0][10][2];
    A[169] = sp[19] * PI0[0][10][3] + sp[18] * PI1[0][10][3] + sp[18] * PI1[0][3][10] + sp[17] * PI2[0][10][3];
    A[170] = sp[19] * PI0[0][10][4] + sp[18] * PI1[0][10][4] + sp[18] * PI1[0][4][10] + sp[17] * PI2[0][10][4];
    A[171] = sp[19] * PI0[0][10][5] + sp[18] * PI1[0][10][5] + sp[18] * PI1[0][5][10] + sp[17] * PI2[0][10][5];
    A[172] = sp[19] * PI0[0][10][6] + sp[18] * PI1[0][10][6] + sp[18] * PI1[0][6][10] + sp[17] * PI2[0][10][6];
    A[173] = sp[19] * PI0[0][10][7] + sp[18] * PI1[0][10][7] + sp[18] * PI1[0][7][10] + sp[17] * PI2[0][10][7];
    A[174] = sp[19] * PI0[0][10][8] + sp[18] * PI1[0][10][8] + sp[18] * PI1[0][8][10] + sp[17] * PI2[0][10][8];
    A[175] = sp[19] * PI0[0][10][9] + sp[18] * PI1[0][10][9] + sp[18] * PI1[0][9][10] + sp[17] * PI2[0][10][9];
    A[176] = sp[19] * PI0[0][10][10] + sp[18] * PI1[0][10][10] + sp[18] * PI1[0][10][10] + sp[17] * PI2[0][10][10];
    A[177] = sp[19] * PI0[0][10][11] + sp[18] * PI1[0][10][11] + sp[18] * PI1[0][11][10] + sp[17] * PI2[0][10][11];
    A[178] = sp[19] * PI0[0][10][12] + sp[18] * PI1[0][10][12] + sp[18] * PI1[0][12][10] + sp[17] * PI2[0][10][12];
    A[179] = sp[19] * PI0[0][10][13] + sp[18] * PI1[0][10][13] + sp[18] * PI1[0][13][10] + sp[17] * PI2[0][10][13];
    A[180] = sp[19] * PI0[0][11][0] + sp[18] * PI1[0][11][0] + sp[18] * PI1[0][0][11] + sp[17] * PI2[0][11][0];
    A[181] = sp[19] * PI0[0][11][1] + sp[18] * PI1[0][1][11];
    A[182] = sp[18] * PI1[0][11][1] + sp[17] * PI2[0][11][1];
    A[183] = sp[19] * PI0[0][11][2] + sp[18] * PI1[0][11][2] + sp[18] * PI1[0][2][11] + sp[17] * PI2[0][11][2];
    A[184] = sp[19] * PI0[0][11][3] + sp[18] * PI1[0][11][3] + sp[18] * PI1[0][3][11] + sp[17] * PI2[0][11][3];
    A[185] = sp[19] * PI0[0][11][4] + sp[18] * PI1[0][11][4] + sp[18] * PI1[0][4][11] + sp[17] * PI2[0][11][4];
    A[186] = sp[19] * PI0[0][11][5] + sp[18] * PI1[0][11][5] + sp[18] * PI1[0][5][11] + sp[17] * PI2[0][11][5];
    A[187] = sp[19] * PI0[0][11][6] + sp[18] * PI1[0][11][6] + sp[18] * PI1[0][6][11] + sp[17] * PI2[0][11][6];
    A[188] = sp[19] * PI0[0][11][7] + sp[18] * PI1[0][11][7] + sp[18] * PI1[0][7][11] + sp[17] * PI2[0][11][7];
    A[189] = sp[19] * PI0[0][11][8] + sp[18] * PI1[0][11][8] + sp[18] * PI1[0][8][11] + sp[17] * PI2[0][11][8];
    A[190] = sp[19] * PI0[0][11][9] + sp[18] * PI1[0][11][9] + sp[18] * PI1[0][9][11] + sp[17] * PI2[0][11][9];
    A[191] = sp[19] * PI0[0][11][10] + sp[18] * PI1[0][11][10] + sp[18] * PI1[0][10][11] + sp[17] * PI2[0][11][10];
    A[192] = sp[19] * PI0[0][11][11] + sp[18] * PI1[0][11][11] + sp[18] * PI1[0][11][11] + sp[17] * PI2[0][11][11];
    A[193] = sp[19] * PI0[0][11][12] + sp[18] * PI1[0][11][12] + sp[18] * PI1[0][12][11] + sp[17] * PI2[0][11][12];
    A[194] = sp[19] * PI0[0][11][13] + sp[18] * PI1[0][11][13] + sp[18] * PI1[0][13][11] + sp[17] * PI2[0][11][13];
    A[195] = sp[19] * PI0[0][12][0] + sp[18] * PI1[0][12][0] + sp[18] * PI1[0][0][12] + sp[17] * PI2[0][12][0];
    A[196] = sp[19] * PI0[0][12][1] + sp[18] * PI1[0][1][12];
    A[197] = sp[18] * PI1[0][12][1] + sp[17] * PI2[0][12][1];
    A[198] = sp[19] * PI0[0][12][2] + sp[18] * PI1[0][12][2] + sp[18] * PI1[0][2][12] + sp[17] * PI2[0][12][2];
    A[199] = sp[19] * PI0[0][12][3] + sp[18] * PI1[0][12][3] + sp[18] * PI1[0][3][12] + sp[17] * PI2[0][12][3];
    A[200] = sp[19] * PI0[0][12][4] + sp[18] * PI1[0][12][4] + sp[18] * PI1[0][4][12] + sp[17] * PI2[0][12][4];
    A[201] = sp[19] * PI0[0][12][5] + sp[18] * PI1[0][12][5] + sp[18] * PI1[0][5][12] + sp[17] * PI2[0][12][5];
    A[202] = sp[19] * PI0[0][12][6] + sp[18] * PI1[0][12][6] + sp[18] * PI1[0][6][12] + sp[17] * PI2[0][12][6];
    A[203] = sp[19] * PI0[0][12][7] + sp[18] * PI1[0][12][7] + sp[18] * PI1[0][7][12] + sp[17] * PI2[0][12][7];
    A[204] = sp[19] * PI0[0][12][8] + sp[18] * PI1[0][12][8] + sp[18] * PI1[0][8][12] + sp[17] * PI2[0][12][8];
    A[205] = sp[19] * PI0[0][12][9] + sp[18] * PI1[0][12][9] + sp[18] * PI1[0][9][12] + sp[17] * PI2[0][12][9];
    A[206] = sp[19] * PI0[0][12][10] + sp[18] * PI1[0][12][10] + sp[18] * PI1[0][10][12] + sp[17] * PI2[0][12][10];
    A[207] = sp[19] * PI0[0][12][11] + sp[18] * PI1[0][12][11] + sp[18] * PI1[0][11][12] + sp[17] * PI2[0][12][11];
    A[208] = sp[19] * PI0[0][12][12] + sp[18] * PI1[0][12][12] + sp[18] * PI1[0][12][12] + sp[17] * PI2[0][12][12];
    A[209] = sp[19] * PI0[0][12][13] + sp[18] * PI1[0][12][13] + sp[18] * PI1[0][13][12] + sp[17] * PI2[0][12][13];
    A[210] = sp[19] * PI0[0][13][0] + sp[18] * PI1[0][13][0] + sp[18] * PI1[0][0][13] + sp[17] * PI2[0][13][0];
    A[211] = sp[19] * PI0[0][13][1] + sp[18] * PI1[0][1][13];
    A[212] = sp[18] * PI1[0][13][1] + sp[17] * PI2[0][13][1];
    A[213] = sp[19] * PI0[0][13][2] + sp[18] * PI1[0][13][2] + sp[18] * PI1[0][2][13] + sp[17] * PI2[0][13][2];
    A[214] = sp[19] * PI0[0][13][3] + sp[18] * PI1[0][13][3] + sp[18] * PI1[0][3][13] + sp[17] * PI2[0][13][3];
    A[215] = sp[19] * PI0[0][13][4] + sp[18] * PI1[0][13][4] + sp[18] * PI1[0][4][13] + sp[17] * PI2[0][13][4];
    A[216] = sp[19] * PI0[0][13][5] + sp[18] * PI1[0][13][5] + sp[18] * PI1[0][5][13] + sp[17] * PI2[0][13][5];
    A[217] = sp[19] * PI0[0][13][6] + sp[18] * PI1[0][13][6] + sp[18] * PI1[0][6][13] + sp[17] * PI2[0][13][6];
    A[218] = sp[19] * PI0[0][13][7] + sp[18] * PI1[0][13][7] + sp[18] * PI1[0][7][13] + sp[17] * PI2[0][13][7];
    A[219] = sp[19] * PI0[0][13][8] + sp[18] * PI1[0][13][8] + sp[18] * PI1[0][8][13] + sp[17] * PI2[0][13][8];
    A[220] = sp[19] * PI0[0][13][9] + sp[18] * PI1[0][13][9] + sp[18] * PI1[0][9][13] + sp[17] * PI2[0][13][9];
    A[221] = sp[19] * PI0[0][13][10] + sp[18] * PI1[0][13][10] + sp[18] * PI1[0][10][13] + sp[17] * PI2[0][13][10];
    A[222] = sp[19] * PI0[0][13][11] + sp[18] * PI1[0][13][11] + sp[18] * PI1[0][11][13] + sp[17] * PI2[0][13][11];
    A[223] = sp[19] * PI0[0][13][12] + sp[18] * PI1[0][13][12] + sp[18] * PI1[0][12][13] + sp[17] * PI2[0][13][12];
    A[224] = sp[19] * PI0[0][13][13] + sp[18] * PI1[0][13][13] + sp[18] * PI1[0][13][13] + sp[17] * PI2[0][13][13];
}


poisson2d_4_cell_integral_1_otherwise::poisson2d_4_cell_integral_1_otherwise() : ufc::cell_integral()
{

}

poisson2d_4_cell_integral_1_otherwise::~poisson2d_4_cell_integral_1_otherwise()
{

}

const std::vector<bool> & poisson2d_4_cell_integral_1_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true});
return enabled;
}

void poisson2d_4_cell_integral_1_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation,
                                    std::size_t local_facet) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 8
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 8
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           8
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights25[25] = { 0.01146508035159253, 0.01980408313204737, 0.0173415064313657, 0.008755499182163834, 0.001865552166877836, 0.02316122192949835, 0.04000728738616045, 0.03503250450337171, 0.01768745211048347, 0.003768701695327616, 0.02752898566446977, 0.04755189705795404, 0.04163896521519497, 0.02102296748732208, 0.004479406797281353, 0.02316122192949835, 0.04000728738616045, 0.03503250450337171, 0.01768745211048347, 0.003768701695327616, 0.01146508035159253, 0.01980408313204737, 0.0173415064313657, 0.008755499182163834, 0.001865552166877837 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q25[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE6_C0_Q25[1][25][15] =
        { { { 0.4451562263925467, -0.03158270668536048, -0.02917048430386152, 0.007134065275287837, 0.004943903029679447, 0.007400352042500199, 0.4292308497443855, -0.3259808246515266, 0.1503557743791674, 0.4856503425184883, -0.3596467139821189, 0.1639976336852157, 0.1397118018034135, -0.04305055107256001, -0.0441496681752572 },
            { 0.01592654198372219, -0.02807254887150224, -0.01830335811304828, 0.03121228065137615, 0.00526393070506929, 0.004989941977801707, 0.8781334117964686, -0.2590231183191913, 0.1013825539475274, 0.1668395961881513, -0.2010466984853998, 0.1204846896211007, 0.3748957403590039, -0.1547924854741929, -0.03789047796688644 },
            { -0.01247552235598089, -0.02155534630393644, 0.01699555179443737, 0.05218483945720868, -0.03106641593597615, -0.005744173270766382, 0.1019684319288195, 0.8062480570403355, -0.116706558733174, 0.006138164662550493, -0.05774073171417197, 0.06382412613772161, 0.2261626835325779, -0.1770562051755823, 0.1488230989359372 },
            { 0.01201682996381069, -0.01283538271691925, -0.03522612897171297, 0.04853270493590327, -0.06676637996799473, 0.03691035339860638, -0.07271147090601132, 0.2316354142279609, 0.7499217248023277, -0.001493593795341834, -0.002517719865904801, 0.02025497909715155, 0.01485684083027115, -0.08700557338279238, 0.1644274023506458 },
            { -0.0416583119739727, -0.004467183014870961, 0.3809151292451657, 0.02161056705024809, -0.0426296719091546, 0.04649788678407878, 0.2289543614127657, -0.5509496449326029, 0.944715296551356, 0.001173970375450428, 0.001064055314646113, 0.002251345306607355, -0.007818220545970629, -0.01229067491169176, 0.03263109524794539 },
            { -0.0104608074149251, -0.009882910554720837, -0.02917048430386149, 0.002978208403733273, 0.003372532094812115, 0.0364046469312236, 0.1462684178010089, -0.1932692389730815, 0.1213514794904439, 0.8141187896221878, -0.1454564307596655, 0.05525614103589478, 0.407481803286924, -0.02370226374113939, -0.1752898829188347 },
            { -0.0375682445666014, -0.02280416702178162, -0.0183033581130482, 0.03197236281291663, 0.007916700284814806, 0.02454708571509872, 0.2235883907136694, -0.1491276939331433, 0.08182541021023008, 0.2089740317665441, -0.1740807544700821, 0.09961071472799284, 1.061780448256613, -0.1878922544505433, -0.1504386719326793 },
            { 0.01807498284392639, -0.0382294890062686, 0.01699555179443741, 0.1079699727035159, -0.08221204064708594, -0.0282573854099213, -0.09968040501450116, 0.4153361542567942, -0.09419334659401922, -0.02951800698283977, -0.07871502090637443, 0.1065782244777391, 0.5731343634285992, -0.3781641813745902, 0.5908806264305884 },
            { -0.005390577424180678, -0.03935180567361963, -0.03522612897171296, 0.1610523488657885, -0.2504274242676092, 0.1815735759415281, 0.02907627798200088, -0.07311139922563287, 0.6052585022594059, 0.002938142303304086, 0.002980654244326443, 0.05424869923296617, -0.02306805887005783, -0.2633880665003607, 0.6528352601038538 },
            { -0.04028099255114129, -0.01913212184648636, 0.3809151292451657, 0.09485961336981583, -0.1942259359664024, 0.2287376521685725, 0.2154358856176661, -0.4962793378530324, 0.7624755311668623, 0.005434138544133003, 0.004366904803487505, 0.007975947057867448, -0.03464388970971474, -0.04519557627241575, 0.1295570522256226 },
            { 0.006330452071431581, 0.006330452071431489, -0.02917048430386149, -0.003734861655345383, -0.05915854740812532, 0.07887806321083372, -0.003734861655345326, -0.05915854740812518, 0.07887806321083367, -0.04504132408843512, 0.780996525962778, -0.04504132408843481, 0.2702479445306085, 0.2702479445306088, -0.2468694949808534 },
            { 0.02231628408102595, 0.02231628408102588, -0.01830335811304822, -0.05064571622229201, -0.03988968597199832, 0.05318624796266434, -0.05064571622229195, -0.03988968597199805, 0.05318624796266425, -0.1025616983147701, 0.2346224089035601, -0.10256169831477, 0.6153701898886192, 0.6153701898886197, -0.2118702936370111 },
            { 0.009547132103506051, 0.009547132103506006, 0.01699555179443738, -0.03566324660967787, 0.04591902450147766, -0.06122536600197025, -0.03566324660967787, 0.04591902450147786, -0.06122536600197036, -0.02288218691353174, 0.004860800046234074, -0.02288218691353164, 0.1372931214811896, 0.1372931214811899, 0.8321666910373413 },
            { -0.03299330380134802, -0.03299330380134807, -0.035226128971713, 0.1535514833203394, -0.2950620293253503, 0.393416039100467, 0.1535514833203394, -0.2950620293253502, 0.393416039100467, 0.0336192054302755, 0.01417330942494135, 0.03361920543027572, -0.2017152325816541, -0.201715232581654, 0.9194204952613123 },
            { -0.0333179517004774, -0.03331795170047746, 0.3809151292451657, 0.1714489698125596, -0.3717049437507882, 0.4956065916677174, 0.1714489698125596, -0.3717049437507881, 0.4956065916677173, 0.009370158884980499, 0.006259461638853972, 0.009370158884980741, -0.05622095330988391, -0.05622095330988387, 0.1824616659077641 },
            { -0.009882910554720835, -0.01046080741492531, -0.02917048430386151, 0.1462684178010089, -0.1932692389730815, 0.1213514794904438, 0.002978208403733247, 0.003372532094812261, 0.0364046469312236, 0.05525614103589468, -0.1454564307596651, 0.8141187896221876, -0.02370226374113946, 0.4074818032869239, -0.1752898829188347 },
            { -0.02280416702178153, -0.03756824456660147, -0.01830335811304827, 0.2235883907136693, -0.1491276939331434, 0.08182541021022997, 0.03197236281291668, 0.007916700284814972, 0.02454708571509863, 0.09961071472799279, -0.174080754470082, 0.2089740317665441, -0.1878922544505434, 1.061780448256613, -0.1504386719326792 },
            { -0.03822948900626855, 0.01807498284392638, 0.01699555179443734, -0.09968040501450112, 0.415336154256794, -0.09419334659401919, 0.1079699727035159, -0.08221204064708577, -0.02825738540992144, 0.1065782244777391, -0.07871502090637443, -0.02951800698283969, -0.3781641813745905, 0.5731343634285994, 0.5908806264305885 },
            { -0.03935180567361959, -0.005390577424180715, -0.03522612897171301, 0.02907627798200103, -0.07311139922563327, 0.6052585022594058, 0.1610523488657885, -0.2504274242676091, 0.1815735759415281, 0.05424869923296603, 0.002980654244326487, 0.002938142303304314, -0.2633880665003609, -0.02306805887005796, 0.6528352601038541 },
            { -0.01913212184648629, -0.04028099255114134, 0.3809151292451656, 0.2154358856176661, -0.4962793378530325, 0.7624755311668623, 0.09485961336981578, -0.1942259359664024, 0.2287376521685722, 0.007975947057867231, 0.004366904803487553, 0.00543413854413325, -0.0451955762724159, -0.03464388970971474, 0.1295570522256225 },
            { -0.03158270668536047, 0.4451562263925465, -0.02917048430386151, 0.4292308497443853, -0.3259808246515266, 0.1503557743791673, 0.007134065275287798, 0.004943903029679502, 0.007400352042500172, 0.1639976336852156, -0.3596467139821189, 0.4856503425184884, -0.04305055107256012, 0.1397118018034137, -0.04414966817525712 },
            { -0.02807254887150218, 0.01592654198372206, -0.01830335811304828, 0.8781334117964685, -0.2590231183191912, 0.1013825539475271, 0.03121228065137619, 0.005263930705069318, 0.004989941977801596, 0.1204846896211005, -0.2010466984853997, 0.1668395961881513, -0.1547924854741931, 0.3748957403590039, -0.03789047796688613 },
            { -0.02155534630393649, -0.01247552235598091, 0.01699555179443733, 0.1019684319288193, 0.8062480570403352, -0.1167065587331741, 0.05218483945720886, -0.03106641593597607, -0.00574417327076652, 0.0638241261377217, -0.05774073171417202, 0.006138164662550499, -0.1770562051755829, 0.2261626835325786, 0.1488230989359375 },
            { -0.01283538271691926, 0.01201682996381065, -0.03522612897171302, -0.07271147090601106, 0.23163541422796, 0.7499217248023273, 0.04853270493590369, -0.06676637996799517, 0.03691035339860653, 0.02025497909715169, -0.002517719865904779, -0.001493593795341724, -0.0870055733827933, 0.01485684083027126, 0.164427402350647 },
            { -0.004467183014870858, -0.04165831197397272, 0.3809151292451656, 0.2289543614127656, -0.5509496449326029, 0.944715296551356, 0.02161056705024803, -0.04262967190915457, 0.04649788678407862, 0.002251345306607177, 0.001064055314646146, 0.001173970375450696, -0.01229067491169195, -0.007818220545970648, 0.03263109524794532 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q25[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q25[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q25[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q25[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q25[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q25[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q25[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q25[0][0][1];
    alignas(32) double sp[4];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = std::abs(sp[2]);
    alignas(32) double BF0[15] = {};
    for (int iq = 0; iq < 25; ++iq)
    {
        // Quadrature loop body setup (num_points=25)
        // Unstructured varying computations for num_points=25
        double w0 = 0.0;
        for (int ic = 0; ic < 15; ++ic)
            w0 += w[0][ic] * FE6_C0_Q25[0][iq][ic];
        alignas(32) double sv25[1];
        sv25[0] = sp[3] * w0;
        const double fw0 = sv25[0] * weights25[iq];
        for (int i = 0; i < 15; ++i)
            BF0[i] += fw0 * FE6_C0_Q25[0][iq][i];
    }
    std::fill(A, A + 15, 0.0);
    for (int i = 0; i < 15; ++i)
        A[i] += BF0[i];
}


poisson2d_4_form_0::poisson2d_4_form_0() : ufc::form()
{
    // Do nothing
}

poisson2d_4_form_0::~poisson2d_4_form_0()
{
    // Do nothing
}

const char * poisson2d_4_form_0::signature() const
{
    return "b8860b01074882aba060b72b831aa941a6021388a714a268e254ef7eab1503ff500ee7adb451fdc7a7babb3a417a70f498f24b9f54d85e580b8995c3a3fef8be";
}

std::size_t poisson2d_4_form_0::rank() const
{
    return 2;
}

std::size_t poisson2d_4_form_0::num_coefficients() const
{
    return 0;
}

std::size_t poisson2d_4_form_0::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * poisson2d_4_form_0::create_coordinate_finite_element() const
{
    return new poisson2d_4_finite_element_1();
}

ufc::dofmap * poisson2d_4_form_0::create_coordinate_dofmap() const
{
    return new poisson2d_4_dofmap_1();
}

ufc::coordinate_mapping * poisson2d_4_form_0::create_coordinate_mapping() const
{
    return new poisson2d_4_coordinate_mapping_1();
}

ufc::finite_element * poisson2d_4_form_0::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new poisson2d_4_finite_element_2();
    case 1:
        return new poisson2d_4_finite_element_2();
    default:
        return nullptr;
    }
}

ufc::dofmap * poisson2d_4_form_0::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new poisson2d_4_dofmap_2();
    case 1:
        return new poisson2d_4_dofmap_2();
    default:
        return nullptr;
    }
}

std::size_t poisson2d_4_form_0::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_0::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_0::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_0::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_0::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_0::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_0::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_0::max_overlap_subdomain_id() const
{
    return 0;
}

bool poisson2d_4_form_0::has_cell_integrals() const
{
    return true;
}

bool poisson2d_4_form_0::has_exterior_facet_integrals() const
{
    return false;
}

bool poisson2d_4_form_0::has_interior_facet_integrals() const
{
    return false;
}

bool poisson2d_4_form_0::has_vertex_integrals() const
{
    return false;
}

bool poisson2d_4_form_0::has_custom_integrals() const
{
    return false;
}

bool poisson2d_4_form_0::has_cutcell_integrals() const
{
    return false;
}

bool poisson2d_4_form_0::has_interface_integrals() const
{
    return false;
}

bool poisson2d_4_form_0::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * poisson2d_4_form_0::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * poisson2d_4_form_0::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * poisson2d_4_form_0::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * poisson2d_4_form_0::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * poisson2d_4_form_0::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * poisson2d_4_form_0::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * poisson2d_4_form_0::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * poisson2d_4_form_0::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * poisson2d_4_form_0::create_default_cell_integral() const
{
    return new poisson2d_4_cell_integral_0_otherwise();
}

ufc::exterior_facet_integral * poisson2d_4_form_0::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * poisson2d_4_form_0::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * poisson2d_4_form_0::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * poisson2d_4_form_0::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * poisson2d_4_form_0::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * poisson2d_4_form_0::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * poisson2d_4_form_0::create_default_overlap_integral() const
{
    return nullptr;
}


poisson2d_4_form_1::poisson2d_4_form_1() : ufc::form()
{
    // Do nothing
}

poisson2d_4_form_1::~poisson2d_4_form_1()
{
    // Do nothing
}

const char * poisson2d_4_form_1::signature() const
{
    return "e6b2a2c4eb8faed06e54a4d9de197822738ce9816a232ef504af776e260490794ea3fbc8946b4b589d182da364986608d9b785f76e2eb4a1c54a169de32cdb5f";
}

std::size_t poisson2d_4_form_1::rank() const
{
    return 1;
}

std::size_t poisson2d_4_form_1::num_coefficients() const
{
    return 1;
}

std::size_t poisson2d_4_form_1::original_coefficient_position(std::size_t i) const
{
    if (i >= 1)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0};
    return position[i];
}

ufc::finite_element * poisson2d_4_form_1::create_coordinate_finite_element() const
{
    return new poisson2d_4_finite_element_1();
}

ufc::dofmap * poisson2d_4_form_1::create_coordinate_dofmap() const
{
    return new poisson2d_4_dofmap_1();
}

ufc::coordinate_mapping * poisson2d_4_form_1::create_coordinate_mapping() const
{
    return new poisson2d_4_coordinate_mapping_1();
}

ufc::finite_element * poisson2d_4_form_1::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new poisson2d_4_finite_element_2();
    case 1:
        return new poisson2d_4_finite_element_2();
    default:
        return nullptr;
    }
}

ufc::dofmap * poisson2d_4_form_1::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new poisson2d_4_dofmap_2();
    case 1:
        return new poisson2d_4_dofmap_2();
    default:
        return nullptr;
    }
}

std::size_t poisson2d_4_form_1::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_1::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_1::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_1::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_1::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_1::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_1::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t poisson2d_4_form_1::max_overlap_subdomain_id() const
{
    return 0;
}

bool poisson2d_4_form_1::has_cell_integrals() const
{
    return true;
}

bool poisson2d_4_form_1::has_exterior_facet_integrals() const
{
    return false;
}

bool poisson2d_4_form_1::has_interior_facet_integrals() const
{
    return false;
}

bool poisson2d_4_form_1::has_vertex_integrals() const
{
    return false;
}

bool poisson2d_4_form_1::has_custom_integrals() const
{
    return false;
}

bool poisson2d_4_form_1::has_cutcell_integrals() const
{
    return false;
}

bool poisson2d_4_form_1::has_interface_integrals() const
{
    return false;
}

bool poisson2d_4_form_1::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * poisson2d_4_form_1::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * poisson2d_4_form_1::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * poisson2d_4_form_1::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * poisson2d_4_form_1::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * poisson2d_4_form_1::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * poisson2d_4_form_1::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * poisson2d_4_form_1::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * poisson2d_4_form_1::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * poisson2d_4_form_1::create_default_cell_integral() const
{
    return new poisson2d_4_cell_integral_1_otherwise();
}

ufc::exterior_facet_integral * poisson2d_4_form_1::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * poisson2d_4_form_1::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * poisson2d_4_form_1::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * poisson2d_4_form_1::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * poisson2d_4_form_1::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * poisson2d_4_form_1::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * poisson2d_4_form_1::create_default_overlap_integral() const
{
    return nullptr;
}

